---
title: "16S_phenology_analyses_full"
author: "Jordan Wilson-Morrison"
date: "2023-11-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE)
```

```{r}
setwd("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology")
```

### Upgrading installed Bioconductor packages:

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install()

### Recommended way to install Bioconductor:

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("BiocVersion")

BiocManager::install()

BiocManager::available()

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(version = "3.18")

BiocManager::install("dada2")

install.packages("devtools")
library("devtools")
devtools::install_github("benjjneb/dada2", ref="v1.8") # change the ref argument to get other versions

################################################################################
##                        DADA2 Processing & Analysis
################################################################################

install.packages("Biostrings")
install.packages("matrixStats")
install.packages("ShortRead")

```{r, message=FALSE, warning=FALSE}
library(BiocManager)
library(dada2)
library(matrixStats)
library(ShortRead)
library(Biostrings)
library(Matrix)

packageVersion("dada2")
packageVersion("ShortRead")
packageVersion("Biostrings")
packageVersion("BiocManager")
packageVersion("Matrix")
```

```{r}
path <- "C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology"

list.files(path)
```

```{r}
###########################################################################################
# Read in the names of the fastq files, and perform some string manipulation to get matched lists of the forward and reverse fastq files:
###########################################################################################

# Forward and reverse fastq filenames have format: SAMPLENAME_R1.fastq and SAMPLENAME_R2.fastq

fnFs <- sort(list.files(path, pattern="_R1.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2.fastq", full.names = TRUE))
```


```{r}
################################################################################
#Extract sample names:
################################################################################

sample.names <- sapply(strsplit(basename(fnFs), "[.]"),`[`, 5)
```


```{r}
################################################################################
##                  INSPECT READ QUALITY PROFILES:
################################################################################

# Start by visualizing the quality profiles of the forward reads:

plotQualityProfile(fnFs[1:2])

# Now visualize the quality profile of the reverse reads:

plotQualityProfile(fnRs[1:2])
```


```{r}
################################################################################
##                              FILTER & TRIM:
################################################################################

# Assign the filenames for the filtered fastq files.
# Place filtered files in filtered/ subdirectory

filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq"))
```

```{r}
# I use standard filtering parameters: maxN=0 (DADA2 requires no Ns), 
# truncQ=2, rm.phix=TRUE and maxEE=2. 
# The maxEE parameter sets the maximum number of “expected errors” allowed in a 
# read, which is a better filter than simply averaging quality scores.
# We want at least 70-80% of the reads reads out (e.g., for CABO_109_16S_R1.fastq: 49955/55692 = 0.9, great recovery).

# NOTE: Did not need to remove primers in this dataset b/c of NGS being so good at QC and whatnot, as Itumeleng explained, but if we did want to, we would do:
# "In the standard 16S workflow, it is generally possible to remove primers (when included on the reads) via the trimLeft parameter (filterAndTrim(..., trimLeft=(FWD_PRIMER_LEN, REV_PRIMER_LEN)))"

out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,230),
                     maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
                     compress=TRUE, multithread=FALSE) # On Windows set multithread=FALSE
head(out)
```


```{r}
################################################################################
##                          LEARNING ERROR RATES
################################################################################

# The DADA2 algorithm makes use of a parametric error model (err) and every 
# amplicon dataset has a different set of error rates. The learnErrors method 
# learns this error model from the data, by alternating estimation of the error 
# rates and inference of sample composition until they converge on a jointly 
# consistent solution. As in many machine-learning problems, the algorithm must 
# begin with an initial guess, for which the maximum possible error rates in 
# this data are used (the error rates if only the most abundant sequence is 
# correct and all the rest are errors).

errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)
```


```{r, warning=FALSE}
################################################################################
##        PLOT & VISUALIZE ESTIMATED ERROR RATES (Sanity Check):
################################################################################

plotErrors(errF, nominalQ=TRUE)

# The error rates for each possible transition (A→C, A→G, …) are shown. 
# Points are the observed error rates for each consensus quality score. 
# The black line shows the estimated error rates after convergence of the 
# machine-learning algorithm. 
# The red line shows the error rates expected under the nominal definition of 
# the Q-score.

# Here the estimated error rates (black line) are a good fit to the observed 
# rates (points), and the error rates drop with increased quality as expected. 
# Everything looks reasonable and we proceed with confidence.
```


```{r}
################################################################################
#                             SAMPLE INFERENCE
################################################################################

# Now apply the core sample inference algorithm to the dereplicated data:

dadaFs <- dada(filtFs, err=errF, multithread=FALSE)
dadaRs <- dada(filtRs, err=errR, multithread=FALSE)
```


```{r}
# Inspecting the returned `dada-class` object:

dadaFs[[1]]

# The DADA2 algorithm inferred 47 true sequence variants from the 2518 unique
# sequences in the 2nd sample. There is much more to the `dada-class` return 
# object than this (see help("dada-class") for some info), including multiple 
# diagnostics about the quality of each denoised sequence variant (beyond the scope of
# introductory tutorial and my own knowledge right now).

# Means that out of 2518 starting unique sequences, only 47 were actual sequence variants (the other >2400 were just noise/errors likely, due to PCR).
```


```{r}
################################################################################
#                             MERGE PAIRED READS
################################################################################

# Now, merge the forward and reverse reads together to obtain the full denoised 
# sequences. Merging is performed by aligning the denoised forward reads with 
# the reverse-complement of the corresponding denoised reverse reads, and then 
# constructing the merged “contig” sequences. By default, merged sequences are 
# only output if the forward and reverse reads overlap by at least 12 bases, 
# and are identical to each other in the overlap region.

mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
# Inspect the merger data.frame from the 2nd sample
head(mergers[[2]])

# The `mergers` object is a list of `data.frames` from each sample. 
# Each `data.frame` contains the merged `$sequence`, its `$abundance`, and the 
# indices of the `$forward` and `$reverse` sequence variants that were merged. 
# Paired reads that did not exactly overlap were removed by `mergePairs`, 
# further reducing spurious output.
```


```{r}
################################################################################
#                           CONSTRUCT SEQUENCE TABLE
################################################################################

# Can now construct an amplicon sequence variant (ASV) table, which is a 
# higher-resolution version of the OTU table produced by traditional methods.

seqtab <- makeSequenceTable(mergers)

dim(seqtab)

## Output: [1]   78 2417
```

```{r}
# Inspect distribution of sequence lengths

table(nchar(getSequences(seqtab)))
```


```{r}
################################################################################
#                             REMOVE CHIMERAS
################################################################################

# The core dada method corrects substitution and indel errors, but chimeras 
# remain. Fortunately, the accuracy of sequence variants after denoising makes 
# identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric 
# sequences are identified if they can be exactly reconstructed by combining a 
# left-segment and a right-segment from two more abundant “parent” sequences.

seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=FALSE, verbose=TRUE)

#Output: Identified 627 bimeras out of 2417 input sequences.
```

```{r}
dim(seqtab.nochim)

#Output: [1]   78 1790
```

```{r}
sum(seqtab.nochim)/sum(seqtab)

#Output: [1] 0.9774347
```


```{r}
################################################################################
#                     TRACK READS THROUGH THE PIPELINE
################################################################################

# As a final progress check, we’ll look at the number of reads that made it 
# through each step in the pipeline:

getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
```

```{r}
# Total number of reads that passed quality filtering

sum(seqtab.nochim)

#Output: [1] 3,046,486
```

```{r}
################################################################################
#                               ASSIGN TAXONOMY
################################################################################

# It is common at this point, especially in 16S/18S/ITS amplicon sequencing, to 
# assign taxonomy to the sequence variants. The DADA2 package provides a native
# implementation of the naive Bayesian classifier method for this purpose. 
# The assignTaxonomy function takes as input a set of sequences to be 
# classified and a training set of reference sequences with known taxonomy, and
# outputs taxonomic assignments with at least minBoot bootstrap confidence.

# We maintain formatted training fastas for the RDP training set, GreenGenes 
# clustered at 97% identity, and the Silva reference database, and additional 
# trainings fastas suitable for protists and certain specific environments have
# been contributed. For fungal taxonomy, the General Fasta release files from 
# the UNITE ITS database can be used as is. To follow along, download the 
# silva_nr99_v138.1_train_set.fa.gz file, and place it in the directory with the 
# fastq files.

taxa <- assignTaxonomy(seqtab.nochim, "C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/taxa/silva_nr99_v138.1_train_set.fa.gz", multithread=FALSE)
```


### NOTE: Extensions for dada2 Taxonomic Assignments:

```{r}
## NOTE: Extensions: The dada2 package also implements a method to make species
# level assignments based on exact matching between ASVs and sequenced reference
# strains. Recent analysis suggests that exact matching (or 100% identity) is 
# the only appropriate way to assign species to 16S gene fragments. 
# Currently, species-assignment training fastas are available for the Silva and
# RDP 16S databases. To follow the optional species addition step, download the
# silva_species_assignment_v138.1.fa.gz file, and place it in the directory with 
# the fastq files.

taxa <- addSpecies(taxa, "C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/taxa/silva_species_assignment_v138.1.fa.gz")
```

```{r}
# Let’s inspect the taxonomic assignments:

taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```


## ALTERNATIVES:

The recently developed IdTaxa taxonomic classification method is also available via the DECIPHER Bioconductor package. The paper introducing the IDTAXA algorithm reports classification performance that is better than the long-time standard set by the naive Bayesian classifier. Here we include a code block that allows you to use IdTaxa as a drop-in replacement for assignTaxonomy (and it’s faster as well!).

Trained classifiers are available from http://DECIPHER.codes/Downloads.html. 

Download the SILVA SSU r132 (modified) file to follow along.

if (!requireNamespace("BiocManager", quietly=TRUE))
  install.packages("BiocManager")
BiocManager::install("DECIPHER")

```{r, message=FALSE, warning=FALSE}
library(DECIPHER) 
packageVersion("DECIPHER")
```

```{r}
dna <- DNAStringSet(getSequences(seqtab.nochim)) # Create a DNAStringSet from the ASVs
```

```{r}
load("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/taxa/IDTaxa/SILVA_SSU_r138_2019.RData") # CHANGE TO THE PATH OF YOUR TRAINING SET
```

```{r}
ids <- IdTaxa(dna, trainingSet, strand="top", processors=NULL, verbose=FALSE) # use all processors
```

```{r}
ranks <- c("domain", "phylum", "class", "order", "family", "genus", "species") # ranks of interest
```

```{r}
# Convert the output object of class "Taxa" to a matrix analogous to the output from assignTaxonomy
taxid <- t(sapply(ids, function(x) {
  m <- match(ranks, x$rank)
  taxa <- x$taxon[m]
  taxa[startsWith(taxa, "unclassified_")] <- NA
  taxa
}))
colnames(taxid) <- ranks; rownames(taxid) <- getSequences(seqtab.nochim)
```

### SIDENOTE:

```{r}
# It is more convenient to use short names for our ASVs (e.g. ASV21) rather than the full DNA sequence when working with some of the tables and visualization.

# Create a new matrix seqtab.print as a copy of seqtab.nochim
seqtab.print <- as.matrix(seqtab.nochim)

# Rename the column names of seqtab.print to ASVXXXX format
colnames(seqtab.print) <- paste0("ASV", seq_along(colnames(seqtab.nochim)))

# Print the dimensions of seqtab.print
dim(seqtab.print)
```


################################################################################
##                    16S DIVERSITY & ABUNDANCE ANALYSES
################################################################################

```{r, message=FALSE, warning=FALSE}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("phyloseq")

#if (!require(devtools)) {
#    install.packages('devtools')
#}
#devtools::install_github('erocoar/ggparl')

library(phyloseq)
library(Biostrings)
library(ggplot2)
library(RColorBrewer)
library(cowplot)
library(ggsignif)
library(ggpubr)
library(tidyverse)
library(vegan)
library(olsrr)
library(plyr)
library(dplyr)
library(kableExtra)
library(factoextra)
library(devtools)
library(GGally)
library(ggsci)
library(ggbreak)
library(ggparl)
library(readxl)
```

```{r}
################################################################################
#                         READ & LOAD IN METADATA
################################################################################

meta<-read_excel("CABO_samples_2022-10-27-MetaData-v1.xlsx", sheet="Meta-data", col_types = "text")
colnames(meta)
```


```{r}
#* qc here
#* generally removing low abundance samples and low abundance ASVs
#* then remove negative controls
#seqtab.print.colfiltered<-seqtab.print#[ , colSums(seqtab.print)>10]
asv<-as.data.frame(seqtab.print)#as.data.frame(seqtab.print.colfiltered)
asv$Name <- unlist(lapply(strsplit(rownames(asv), "[_.]"), function(r) {
  if (r[1] == "BlankpcrCES") {
    return("BlankpcrCES")
  } else {
    return(paste(r[1:3], collapse = "_"))
  }
}))
asv[1:10,1790:ncol(asv)]
```

```{r}
asv_joined<-plyr::join(asv, meta, by="Name", type="left")
dim(asv)
dim(meta)
dim(asv_joined)
```

```{r}
summary(rowSums(seqtab.print))
summary(colSums(seqtab.print))
```

```{r}
asv_joined[grepl("control",asv_joined$Species, ignore.case=T)|asv_joined$Alias=="BlankpcrCES",1791:ncol(asv_joined) ]
```

```{r}
negControlVals<-ceiling(colMeans(asv_joined[grepl("NegativeControl",asv_joined$Species, ignore.case=T), grepl("ASV", colnames(asv_joined)) ]))
#* get asv columns from neg controls, 
#* remove those counts from all other row's counts by column
cols<-colnames(asv_joined)[grepl("ASV", colnames(asv_joined))]
asv_negRm<-asv_joined[cols]
asv_negRm[cols]<-lapply(cols, function(c) asv_joined[[c]]-negControlVals[[c]] )
asv_negRm<-as.matrix(asv_negRm)
asv_negRm[asv_negRm<0]<-0
asv_negRm<-cbind(asv_negRm, asv_joined[,!grepl("ASV", colnames(asv_joined))] )

asv_joined[1:10,1:10]
```

```{r}
asv_negRm[1:10,1:10]
```

```{r}
sum(grepl("control",asv_negRm$Species, ignore.case=T))
```

```{r}
test<-asv_negRm[asv_negRm$Alias=="BlankpcrCES",]
summary(as.numeric(test[1,grepl("ASV", colnames(test))]))
```

```{r}
which(as.numeric(test[1,grepl("ASV", colnames(test))])!=0)
```

```{r}
test[1,1:11] #* not removing explicitly because this will be removed in the next block anyway, 
# * aka, one ASV found in this blank PCR (ASV11) and it's already being removed.
```

```{r}
#############################################
## SIDENOTE!:
#############################################

# Just like with the `seqtab.print`, it's more convenient to use short names for our ASVs (e.g. ASV21) rather than the full DNA sequence when working with some of the tables and visualization.

# Create a copy of the taxa table
taxa_rdp <- taxa

# Rename the column names of taxa_rdp to ASVXXXX format
rownames(taxa_rdp) <- paste0("ASV", seq_along(rownames(taxa_rdp)))

# Create a copy of the taxid table
taxid_rdp <- taxid

# Rename the column names of taxid_rdp to ASVXXXX format
rownames(taxid_rdp) <- paste0("ASV", seq_along(rownames(taxid_rdp)))
```

```{r}
asv_negRm<-asv_negRm[!grepl("NegativeControl",asv_negRm$Species, ignore.case=T) & !asv_negRm$Alias=="BlankpcrCES",]

scaleFactor<-exp(mean(log(rowSums(asv_negRm[,cols]))))
asv_scaled<-asv_negRm
asv_scaled[,cols]<-as.data.frame(t(apply(asv_scaled[,cols], MARGIN=1, FUN=function(i) round(scaleFactor*i/sum(i)) )))

# asv_joined[1:10,1:10]
# asv_negRm[1:10,1:10]
# asv_scaled[1:10,1:10]
rdp<-as.data.frame(taxa_rdp)
asv_scaled_noPlants<-cbind(asv_scaled[, c(rownames(rdp[!rdp$Order%in%c("Chloroplast") & !rdp$Family%in%c("Mitochondria"),]))],
      asv_scaled[,!grepl("ASV",colnames(asv_scaled))])

dim(asv_scaled_noPlants)
```

```{r}
asv_scaled_noPlants[1:10,1:10]
```

Diversity indices are statistics used to summarize the diversity of a community in which each member belongs to a unique group. In ecology, species richness refers to number of species and species evenness refers to homogeneity of the species. That is, the more equal the proportions for each of the groups, the more homogeneous, or even, they are. Different fields of application may use different terminology for these concepts.

Data Exploration and alpha diversity

Objective: To determine whether sequence depth was 'enough' to capture community dynamics

How: 

1. **Preston log-normal curve** (if we can see the entire graph, then we have captured the rare taxa and super abundant)
2. **Species accumulation curve** (if we see the plateau then we have sampled all there was to sample)

```{r}
################################################################################
# CALCULATE SHANNON (`alphaDiv`), ASV RICHNESS (`specnumber`), & SIMPSON (`simpson`)
################################################################################

# And place as columns in joined metadata

library(vegan)
#meta_16s<-meta[grepl("16S", meta$Name),]
#asv_m<-plyr::join(asv_scaled_noPlants, meta_16s, by="Name")
asv_scaled_noPlants$alphaDiv<-vegan::diversity(asv_scaled_noPlants[,grepl("ASV",colnames(asv_scaled_noPlants))], index="shannon")
asv_scaled_noPlants$specnumber<-vegan::specnumber(asv_scaled_noPlants[,grepl("ASV",colnames(asv_scaled_noPlants))])
asv_scaled_noPlants$simpson<-vegan::diversity(asv_scaled_noPlants[,grepl("ASV",colnames(asv_scaled_noPlants))], index="simpson")
asv_scaled_noPlants[1:10,1748:ncol(asv_scaled_noPlants)]
```


```{r}
################################################################################
#                         PRESTON LOG-NORMAL CURVE
################################################################################

# If we can see the entire graph, then we have captured the rare taxa and super abundant

preston<-vegan::prestondistr(t(asv_scaled_noPlants[,grepl("ASV",colnames(asv_scaled_noPlants))]) )
preston_lognormal <- plot(preston)

preston_lognormal
```

```{r}
# Save the plot as a PDF file
pdf("preston_lognormal.pdf")
plot(preston)
dev.off()
```



```{r}
################################################################################
#                        SPECIES ACCUMULATION CURVE
################################################################################

# If we see the plateau then we have sampled all there was to sample

plot(specaccum(t(asv_scaled_noPlants[,grepl("ASV",colnames(asv_scaled_noPlants))])))
```


```{r}
plot(specaccum(t(asv_scaled_noPlants[!grepl("Positive_Control",asv_scaled_noPlants$Species),grepl("ASV",colnames(asv_scaled_noPlants))])))
```

```{r}
# Save the plot as a PDF file
pdf("spec_accumulation_curve.pdf")
plot(
  specaccum(
    t(asv_scaled_noPlants[!grepl("Positive_Control", asv_scaled_noPlants$Species), grepl("ASV", colnames(asv_scaled_noPlants))])
  ),
  xlab = "Read Count",
  ylab = "Number of ASVs"
)
dev.off()
```



```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(car)
library(carData)
library(performance)
library(easystats)
library(lme4)
library(lmtest)
library(lmPerm)
library(MASS)
library(HH)
library(boot)
library(simpleboot)
library(MuMIn)
library(pwr)
library(multcomp)
library(tidyverse)
library(dplyr)
library(tidyr)
library(effects)
library(readr)
```

```{r}
# Create & Write "asv_scaled_noPlants.csv"
write.csv(asv_scaled_noPlants, file="asv_scaled_noPlants.csv")
getwd()
```


################################################################################
MAYBE ADD THIS TO THE END INSTEAD ???
################################################################################

```{r}
# Let's attach Functional Traits from `spectra` object from Shan/spectrolab:

# Create the full path to the CSV file in the other directory
spec_path <- file.path("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/Spectral_Files/Phenology/Processed_Spectra", "ref_spec_phen.csv")

# Read the CSV file
refl_trait_data <- read.csv(spec_path)

# Join trait data
asv_scaled_noPlants<-plyr::join(asv_scaled_noPlants, refl_trait_data, by="sample_id", type="left")

# Impute NAs with median for numeric columns
asv_scaled_noPlants[, sapply(asv_scaled_noPlants, is.numeric)] <-
  lapply(asv_scaled_noPlants[, sapply(asv_scaled_noPlants, is.numeric)], 
         function(x) ifelse(is.na(x), median(x, na.rm = TRUE), x))

dim(asv_scaled_noPlants)
dim(refl_trait_data)
```


```{r}
# Let's attach Functional Traits from `spectra` object from Shan/spectrolab:

# Create the full path to the CSV file in the other directory
spec_path <- file.path("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/Spectral_Files/Phenology/Processed_Spectra", "ref_spec_phen.csv")

# Read the CSV file
refl_trait_data <- read.csv(spec_path)

asv_traits_joined<-plyr::join(asv_scaled_noPlants, refl_trait_data, by="sample_id", type="left")

# Convert GDDs & Species from character to factor
asv_traits_joined$`Growing-Degree-Days-5C` <- as.numeric(asv_traits_joined$`Growing-Degree-Days-5C`)
asv_traits_joined$Species <- as.factor(asv_traits_joined$Species)


dim(asv_scaled_noPlants)
dim(refl_trait_data)
dim(asv_traits_joined)
```

```{r}
write.csv(asv_traits_joined, file="asv_traits_joined.csv")
write.csv(asv_scaled_noPlants, file="asv_scaled_noPlants.csv")
getwd()
```

################################################################################

################################################################################
#                             ALPHA DIVERSITY
################################################################################

################################################################################
#                         1. SHANNON DIVERSITY (H')
################################################################################

1. **Shannon Diversity (H):** The higher the value of H, the higher the diversity of species in a particular community. The lower the value of H, the lower the diversity. A value of H = 0 indicates a community that only has one species.

```{r, message=FALSE, warning=FALSE}
################################################################################
##    (a) TOTAL SHANNON DIVERSITY (ACROSS ALL GROWING DEGREE DAYS & HOSTS):
################################################################################

library(cowplot)
library(ggplot2)
library(vegan)

set.seed(19850)
#Phenology_keep<-meta$Project=="Phenology-Group" # Set new funtion to use 
#meta.Phenology<- meta[Phenology_keep,] #Get the desired files from the metadata

#------------------------------------------------------------------------------------------------------
#**IMPORTANT NOTE: This is wat I WOULD do, if I was using all sequence files for all projects, but since I pre-filtered to only have "Phenology" sequences, the `asv_scaled_noPlants` is fine as-is!!!:

asv_scaled_noPlants_Phenology<-asv_scaled_noPlants[asv_scaled_noPlants$Project=="Phenology",] #Get the desired files from the ASV table
#------------------------------------------------------------------------------------------------------

#x<-asv_scaled_noPlants_Phenology$
#x$newShannon<-diversity(x[,grepl("ASV",colnames(x))])

scale_custom_two <- list(
      scale_color_manual(values = c("#ecb21e", "#812e91")),
      scale_fill_manual(values = c("#ecb21e", "#812e91" ))
)

scale_custom_3 <- list(
      scale_color_manual(values = c("#ecb21e", "#812e91", "dodgerblue3")),
      scale_fill_manual(values = c("#ecb21e", "#812e91", "dodgerblue3" ))
)

scale_custom_three <- list(
      scale_color_manual(values = c("dodgerblue4","slategray4","deeppink4" )),
      scale_fill_manual(values = c("dodgerblue4","slategray4","deeppink4"  ))
)

scale_custom_8 <- list(
      scale_color_manual(values = c("darkslategray","darkgreen","darkolivegreen", "darkseagreen","goldenrod1","goldenrod2","goldenrod3", "goldenrod4")),
      scale_fill_manual(values = c("darkslategray","darkgreen","darkolivegreen", "darkseagreen","goldenrod1","goldenrod2","goldenrod3", "goldenrod4" ))
)

scale_custom_four <- list(
      scale_color_manual(values = c("black","blue", "burlywood4","red4")),
      scale_fill_manual(values = c("black","blue", "burlywood4","red4" ))
)

scale_custom_five <- list(
      scale_color_manual(values = c("black","purple", "burlywood4","red4")),
      scale_fill_manual(values = c("black","purple", "burlywood4","red4" ))
)

scale_custom_six <- list(
      scale_color_manual(values = c("black","orange", "burlywood4","red4")),
      scale_fill_manual(values = c("black","orange", "burlywood4","red4" ))
)


Total_shannon=  ggplot(asv_scaled_noPlants
                 ,aes(x = `Project`,
             y =alphaDiv,
             color = `Project`))+
  geom_boxplot(outlier.colour="lightblue3", outlier.shape=8,outlier.size=1.5,show.legend=F)+
  geom_point(position = position_jitterdodge())+
   scale_y_continuous()+
   scale_y_continuous()+
  ylab("Total Shannon Diversity H'")+
  scale_colour_manual(values=c("black","blue", "burlywood4","red3" ))+
  coord_cartesian(xlim = c(0,NA ), clip = "off")+
   coord_cartesian(ylim = c(0, NA), clip = "off")+
   theme_cowplot(12)
```

```{r}
Total_shannon
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_shannon1.jpeg", plot = Total_shannon, device = "jpeg", width = 10, height = 6, units = "in")
```


```{r, warning=FALSE}
TS <- ggplot(asv_scaled_noPlants,aes(x = Project, y = alphaDiv, fill = Project)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab("Total Shannon Diversity H'")+
  ylim(c(0,NA))+
  scale_custom_four
TS+theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_shannon2.jpeg", plot = TS, device = "jpeg", width = 10, height = 6, units = "in")
```


```{r, warning=FALSE}
################################################################################
##        (b) TOTAL SHANNON DIVERSITY (BETWEEN HOST TREE SPECIES ONLY):
################################################################################

Phenology_diversity <- ggplot(asv_scaled_noPlants,aes(x = Species, y = alphaDiv, fill = Species)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab(" Phenology Group Shannon H")+
 #scale_x_discrete(limits=c("Deciduous", "Evergreen"))+
  ylim(c(0,NA)) + 
  scale_custom_3
Phenology_diversity+theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_shannon_spp.jpeg", plot = Phenology_diversity, device = "jpeg", width = 10, height = 6, units = "in")
```


################################################################################
###                 Selecting by Subproject: PHENOLOGY
################################################################################


**NOTE:** Everything prior to this can be applied to the entire sequence dataset and then filtered by subproject, as I will do here for Phenology. I just used Phenology only in the prior parts because I am new to these analyses, so I subsetted Phenology out of the entire set of sequences. 

Next time/for final thesis, you can go back and apply the prior bioinformatics to ALL sequences, and then filter at this part y subproject. I just did it this way (i.e., only Phenology all the way through) because I have the conference coming very soon, so we're only focussing on the Phenolgy subproject and so that I could practice with a smaller sequence dataset.

```{r}
# Exclude rows with "323" in the `Growing-Degree-Days-5C` variable

asv_scaled_noPlants_filtered <- subset(asv_scaled_noPlants, `Growing-Degree-Days-5C` != 323)

asv_scaled_noPlants_Phenology_filtered <- subset(asv_scaled_noPlants_Phenology, `Growing-Degree-Days-5C` != 323)
```

```{r}
# Convert GDD variable to factor with desired order
asv_scaled_noPlants_Phenology_filtered$`Growing-Degree-Days-5C` <- factor(asv_scaled_noPlants_Phenology_filtered$`Growing-Degree-Days-5C`,
                                                                         levels = c(437, 605, 1087, 1606, 1992, 2140, 2219))

asv_scaled_noPlants_filtered$`Growing-Degree-Days-5C` <- factor(asv_scaled_noPlants_filtered$`Growing-Degree-Days-5C`,
                                                                         levels = c(437, 605, 1087, 1606, 1992, 2140, 2219))
```

```{r}
#-------------------------------------------------------------------------------
## NOTE: For Later Statistics (Need GDDs to be CONTINUOUS Variable!!!)
#-------------------------------------------------------------------------------

#Create new objects & convert `Species` to factor & `Growing-Degree-Days-5C` to numeric for ALL objects used in stats

asv_scaled_noPlants_Phen_filt_LMM <- as.data.frame(asv_scaled_noPlants_Phenology_filtered)

# Convert the factor to numeric without changing the values
asv_scaled_noPlants_Phen_filt_LMM$`Growing-Degree-Days-5C` <- as.numeric(as.character(asv_scaled_noPlants_Phen_filt_LMM$`Growing-Degree-Days-5C`))

# Convert to `Species` to factor
asv_scaled_noPlants_Phen_filt_LMM$Species <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Species)

# Convert to `sample_id` to factor
asv_scaled_noPlants_Phen_filt_LMM$sample_id <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$sample_id)

# Convert to `Plant_ID` to factor
asv_scaled_noPlants_Phen_filt_LMM$Plant_ID <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Plant_ID)

# Rename the 'Growing-Degree-Days-5C' variable to 'GDD5C'
colnames(asv_scaled_noPlants_Phen_filt_LMM)[colnames(asv_scaled_noPlants_Phen_filt_LMM) == 'Growing-Degree-Days-5C'] <- 'GDD_5C'

# Create a column `GDD_5C_bins` to bin (categorize) continuous GDDs

sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

asv_scaled_noPlants_Phen_filt_LMM$GDD_5C_bins <- cut(asv_scaled_noPlants_Phen_filt_LMM$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

asv_scaled_noPlants_Phen_filt_LMM<-plyr::join(asv_scaled_noPlants_Phen_filt_LMM, refl_trait_data, by="sample_id", type="left")

# Convert `Plant_ID` to factor
asv_scaled_noPlants_Phen_filt_LMM$Plant_ID <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Plant_ID)
```





```{r, warning=FALSE}
################################################################################
##            (c) TOTAL SHANNON DIVERSITY (BETWEEN GDDs ONLY):
################################################################################

Phenology_diversity_gdd <- ggplot(asv_scaled_noPlants_Phenology_filtered,aes(x = `Growing-Degree-Days-5C`, y = alphaDiv, fill = `Growing-Degree-Days-5C`)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab("Phenology Group Shannon H'")+
 #scale_x_discrete(limits=c("Deciduous", "Evergreen"))+
  ylim(c(0,NA)) + 
  scale_custom_8
Phenology_diversity_gdd+theme_cowplot(12)
```


```{r, message=FALSE, warning=FALSE}
################################################################################
##            (d) SHANNON DIVERSITY (BETWEEN SPECIES & GDDs!):
################################################################################

# Define colors for each species (colorblind-friendly choices)
species_colors <- c("blue", "#800080", "#00ffff", "#e7298a", "purple", "#e6ab02", "#a6761d")

# Define colors for each collection month (unique and colorblind-friendly choices)
collection_month_colors <- c("#CCCC66", "#7570b3", "#6699CC", "pink", "#FFA54F", "#ecb21e", "#812e91")

# Plot with updated dataset and GDD order
Phenology_diversity_gddspec2 <- ggplot(asv_scaled_noPlants_Phenology_filtered, aes(x = `Growing-Degree-Days-5C`, y = alphaDiv)) +
  geom_rect(data = asv_scaled_noPlants_Phenology_filtered, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                                                ymin = -Inf, ymax = 0.0025, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("Shannon Index (H')") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_diversity_gddspec2 + theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Shannon_phenology_16S.jpeg", plot = Phenology_diversity_gddspec2, device = "jpeg", width = 10, height = 6, units = "in")
```


*Interpretation:* The consistent higher Shannon diversity observed in Populus across all growing degree days (GDDs) suggests that the leaf microbiome of Populus exhibits greater overall diversity and evenness compared to Betula throughout the growing season. This finding implies that Populus supports a more diverse and balanced microbial community on its leaves.

The contrasting pattern between the ASV richness and Shannon diversity results highlights an interesting discrepancy in the two diversity metrics. While ASV richness showed an alternating pattern between Betula and Populus, indicating temporal shifts in the number of unique microbial taxa associated with each host, Shannon diversity consistently favored Populus.

This disparity suggests that although the number of unique taxa fluctuates between Betula and Populus, the relative abundances of those taxa might differ significantly. Populus appears to maintain a more even distribution of microbial taxa, resulting in higher Shannon diversity. In contrast, Betula may have higher turnover rates or fluctuations in the abundance of specific taxa, leading to the observed pattern of alternating ASV richness.

It is important to note that diversity metrics like ASV richness and Shannon diversity capture different aspects of the microbiome composition and should be interpreted together. The alternating ASV richness pattern suggests temporal variations in the presence of specific taxa, while the consistent higher Shannon diversity in Populus indicates a more balanced and diverse microbial community overall.

In summary, the consistent higher Shannon diversity in Populus suggests a more diverse and even microbial community on its leaves compared to Betula throughout the growing season. This finding, along with the alternating ASV richness pattern, indicates complex dynamics in the composition and distribution of microbial taxa between the two host species. Further investigation into the specific factors driving these patterns can provide valuable insights into the ecological dynamics of leaf microbiomes.



################################################################################
#               2. ASV RICHNESS (NUMBER OF MICROBIAL SPECIES)
################################################################################


```{r, message=FALSE, warning=FALSE}
################################################################################
#             (a) TOTAL ASV RICHNESS (ACROSS ALL SPECIES & GDDs):
################################################################################

Total_Richness=  ggplot(asv_scaled_noPlants
                 ,aes(x = `Project`,
             y =specnumber,
             color = `Project`))+
  geom_boxplot(outlier.colour="lightblue3", outlier.shape=8,outlier.size=1.5,show.legend=F)+
  geom_point(position = position_jitterdodge())+
   scale_y_continuous()+
   scale_y_continuous()+
  ylab("Total ASV Richness")+
  coord_cartesian(xlim = c(0,NA ), clip = "off")+
   coord_cartesian(ylim = c(0, NA), clip = "off")+
  scale_custom_five+
   theme_cowplot(12)
```

```{r}
Total_Richness
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_richness1.jpeg", plot = Total_Richness, device = "jpeg", width = 10, height = 6, units = "in")
```


```{r, warning=FALSE}
TD <- ggplot(asv_scaled_noPlants,aes(x = Project, y = specnumber, fill = Project)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab("Total ASV Richness")+
  ylim(c(0,NA))+
  scale_custom_five
TD+theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_richness2.jpeg", plot = TD, device = "jpeg", width = 10, height = 6, units = "in")
```


```{r, warning=FALSE}
################################################################################
#           (b) TOTAL ASV RICHNESS (BETWEEN SPECIES, ACROSS ALL GDDs):
################################################################################

set.seed(19850)


scale_custom_8 <- list(
      scale_color_manual(values = c("darkslategray","darkgreen","darkolivegreen", "darkseagreen","goldenrod1","goldenrod2","goldenrod3", "goldenrod4")),
      scale_fill_manual(values = c("darkslategray","darkgreen","darkolivegreen", "darkseagreen","goldenrod1","goldenrod2","goldenrod3", "goldenrod4" ))
)


Phenology_Richness <- ggplot(asv_scaled_noPlants,aes(x = Species, y = specnumber, fill = Species)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab(" Phenology Group ASV Richness")+
 #scale_x_discrete(limits=c("Deciduous", "Evergreen"))+
  ylim(c(0,NA)) + 
  scale_custom_3
Phenology_Richness+theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "Total_richness_spp.jpeg", plot = Phenology_Richness, device = "jpeg", width = 10, height = 6, units = "in")
```


```{r, warning=FALSE}
################################################################################
#             (c) TOTAL ASV RICHNESS (BETWEEN GDDs ONLY):
################################################################################

#Plot
Phenology_Richness_ggdd <- ggplot(asv_scaled_noPlants_Phenology_filtered,aes(x = `Growing-Degree-Days-5C`, y = specnumber, fill = `Growing-Degree-Days-5C`)) +
  geom_boxjitter(outlier.color = NA, jitter.shape = 21, jitter.color = NA,size=1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "none") +
  ylab(" Phenology Group ASV Richness")+
 #scale_x_discrete(limits=c("Deciduous", "Evergreen"))+
  ylim(c(0,NA)) + 
  scale_x_discrete(breaks = as.character(sort(as.numeric(unique(asv_scaled_noPlants_Phenology_filtered$`Growing-Degree-Days-5C`)),
                                 decreasing = F)))+
   scale_custom_8

Phenology_Richness_ggdd+theme_cowplot(12)+
  ggpubr::stat_compare_means(method="wilcox", comparisons = lapply(c(2:8), function(i) c(1,i)))
```


```{r, message=FALSE, warning=FALSE}
################################################################################
#             (d) TOTAL ASV RICHNESS (BETWEEN SPECIES AND GDDs):
################################################################################

# Define colors for each species (colorblind-friendly choices)
species_colors <- c("blue", "#800080", "#00ffff", "#e7298a", "purple", "#e6ab02", "#a6761d")

# Define colors for each collection month (unique and colorblind-friendly choices)
collection_month_colors <- c("#CCCC66", "#7570b3", "#6699CC", "pink", "#FFA54F", "#ecb21e", "#812e91")

# Plot with updated dataset and GDD order
Phenology_richness_gddspec2 <- ggplot(asv_scaled_noPlants_Phenology_filtered, aes(x = `Growing-Degree-Days-5C`, y = specnumber)) +
  geom_rect(data = asv_scaled_noPlants_Phenology_filtered, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                                                ymin = -Inf, ymax = 0.05, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("ASV Richness") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_richness_gddspec2 + theme_cowplot(12)
```

```{r, message=FALSE, warning=FALSE}
# Save the plot as a JPEG image
ggsave(filename = "ASVrich_phenology_16S.jpeg", plot = Phenology_richness_gddspec2, device = "jpeg", width = 10, height = 6, units = "in")
```

```{r}
write.csv(asv_scaled_noPlants_filtered, file="asv_scaled_noPlants_filtered.csv")
getwd()

write.csv(asv_scaled_noPlants_Phenology_filtered, file="asv_scaled_noPlants_Phenology_filtered.csv")
getwd()
```

*Interpretation:* The alternating pattern of ASV richness between Betula and Populus across different growing degree days (GDDs) suggests that there might be temporal fluctuations in the composition and abundance of microbial taxa associated with each host species. These fluctuations could be influenced by various factors such as host-specific interactions, environmental conditions, and microbial community dynamics.

The observed swapping of ASV richness between the two host species indicates that their leaf microbiomes are dynamically responding to the changing phenological stages represented by GDDs. It suggests that the microbial communities associated with Betula and Populus are responding differently to the environmental cues or host-specific factors at different points in the growing season.

This dynamic pattern of ASV richness swapping between the host species systems highlights the complexity of plant-microbe interactions and the potential for temporal shifts in the composition and diversity of leaf microbiomes. Further investigation into the specific factors driving these temporal dynamics and their ecological implications could provide valuable insights into the coexistence and dynamics of microbial communities within different host species systems.

Thus, the alternating pattern of ASV richness between Betula and Populus across GDDs suggests dynamic temporal fluctuations in the microbial communities associated with each host species, highlighting the need for further investigation into the underlying mechanisms and ecological implications of these dynamics.

Also:

The fact that the Betula and Populus individuals are from the same locality and located near each other adds an interesting dimension to the observed alternating pattern of ASV richness.

The alternating pattern of ASV richness between Betula and Populus, despite their close proximity, suggests that there may be host-specific factors influencing the composition and diversity of their leaf microbiomes. These factors could include variations in host physiology, leaf surface characteristics, or other plant-specific traits that influence the recruitment and establishment of microbial taxa.

The observed swapping of ASV richness between the two host species, even in close proximity, implies that the leaf microbiomes of Betula and Populus respond differently to local environmental conditions or host-specific factors. It could indicate that each host species has a distinct microbial community assembly process, leading to temporal variations in ASV richness.

These findings highlight the importance of considering host species-specific effects when studying leaf microbiomes. They suggest that even in a shared environment, different host species can shape the composition and dynamics of their associated microbial communities in unique ways.

In summary, the alternating pattern of ASV richness between Betula and Populus, despite their close proximity, suggests the influence of host-specific factors on the leaf microbiomes. This finding emphasizes the need to consider host species-specific effects and their potential contributions to the observed temporal variations in microbial diversity.


```{r}
################################################################################
## COMBINING PLOTS AS PANELS INTO RESPECTIVE FIGURES
################################################################################

library(gridExtra)

# Total Alpha Diversity (for sequencing QC):
total_alpha_combined <- arrangeGrob(Phenology_Richness, Phenology_diversity, ncol=3)

ggsave("total_alpha_combined.png", total_alpha_combined, width=14, height=8)

# Alpha Diversity as function of GDDs:
alpha_combined <- arrangeGrob(Phenology_richness_gddspec2, Phenology_diversity_gddspec2, ncol=3)

ggsave("alpha_combined.png", alpha_combined, width=16, height=6)
```
################################################################################
## INTRASPECIFIC PLOTS
################################################################################

## BETULA:

```{r}
####################################################
## ASV RICHNESS
####################################################

betula_data <- subset(asv_scaled_noPlants_Phenology_filtered, Species == "Betula_populifolia")

# Plot with updated dataset and GDD order
Phenology_richness_gddspec_betula <- ggplot(betula_data, aes(x = `Growing-Degree-Days-5C`, y = specnumber)) +
  geom_rect(data = betula_data, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                             ymin = -Inf, ymax = 0.05, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("ASV Richness") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_richness_gddspec_betula + theme_cowplot(12)
```


```{r}
################################################################################
## SHANNON
################################################################################
# Plot with updated dataset and GDD order
Phenology_diversity_gddspec_betula <- ggplot(betula_data, aes(x = `Growing-Degree-Days-5C`, y = alphaDiv)) +
  geom_rect(data = betula_data, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                             ymin = -Inf, ymax = 0.0025, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("Shannon Index (H')") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_diversity_gddspec_betula + theme_cowplot(12)
```


```{r}
################################################################################
## COMBINING PLOTS AS PANELS INTO RESPECTIVE FIGURES
################################################################################

library(gridExtra)

# Alpha Diversity as function of GDDs:
alpha_combined_betula <- arrangeGrob(Phenology_richness_gddspec_betula, Phenology_diversity_gddspec_betula, ncol=3)

ggsave("alpha_combined_betula.png", alpha_combined_betula, width=16, height=6)
```
##################################
## POPULUS:
##################################

```{r}
################################################################################
## ASV RICHNESS
################################################################################
# Filter the dataset to include only "Populus_tremuloides"
populus_data <- subset(asv_scaled_noPlants_Phenology_filtered, Species == "Populus_tremuloides")

# Plot with updated dataset and GDD order
Phenology_richness_gddspec_populus <- ggplot(populus_data, aes(x = `Growing-Degree-Days-5C`, y = specnumber)) +
  geom_rect(data = populus_data, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                               ymin = -Inf, ymax = 0.05, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("ASV Richness") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_richness_gddspec_populus + theme_cowplot(12)
```


```{r}
################################################################################
## SHANNON
################################################################################
# Filter the dataset to include only "Populus_tremuloides"
populus_data <- subset(asv_scaled_noPlants_Phenology_filtered, Species == "Populus_tremuloides")

# Plot with updated dataset and GDD order for "Populus_tremuloides"
Phenology_diversity_gddspec_populus <- ggplot(populus_data, aes(x = `Growing-Degree-Days-5C`, y = alphaDiv)) +
  geom_rect(data = populus_data, aes(xmin = as.numeric(`Growing-Degree-Days-5C`)-0.5, xmax = as.numeric(`Growing-Degree-Days-5C`)+0.5,
                                      ymin = -Inf, ymax = 0.0025, fill = `Collection-Month`), alpha = 0.2) +
  geom_boxjitter(aes(fill = Species), outlier.color = NA, jitter.shape = 21, jitter.color = NA, size = 1.1,
                 jitter.height = 0.05, jitter.width = 0.075, errorbar.draw = TRUE) +
  theme(legend.position = "bottom") +
  ylab("Shannon Index (H')") +
  ylim(c(0, NA)) +
  scale_x_discrete() +
  scale_fill_manual(values = collection_month_colors, name = "Collection Month", labels = function(x) str_replace_all(x, "_", " ")) +
  labs(x = "Growing Degree Days (5C)", fill = "Species") +
  guides(fill = guide_legend(title = "Species"))

Phenology_diversity_gddspec_populus + theme_cowplot(12)
```



```{r}
################################################################################
## COMBINING PLOTS AS PANELS INTO RESPECTIVE FIGURES
################################################################################

library(gridExtra)

# Alpha Diversity as function of GDDs:
alpha_combined_populus <- arrangeGrob(Phenology_richness_gddspec_populus, Phenology_diversity_gddspec_populus, ncol=3)

ggsave("alpha_combined_populus.png", alpha_combined_populus, width=16, height=6)
```


################################################################################
##                              BETA DIVERSITY
################################################################################

```{r}
library(vegan)
library(ape)

#Beta diversity (Bray-Curtis Dissimilarity Matrix based on PCoA):

asv<-asv_scaled_noPlants_Phen_filt_LMM[rowSums(asv_scaled_noPlants_Phen_filt_LMM[,grepl("ASV", colnames(asv_scaled_noPlants_Phen_filt_LMM))])!=0, ]
distance="bray"
dist.mat<-vegan::vegdist(asv[,grepl("ASV", colnames(asv))], method=distance)
pcoa.asv<-pcoa(dist.mat)
pcoa.table_phenology<-cbind(pcoa.asv$vectors[,1:5], asv[,!grepl("ASV", colnames(asv))])
pcoa.table_phenology$Axis.1
```

```{r}
#To find the total proportion of variance explained by each PCoA axes, simply view the output of the `pcoa.asv` object, which has the PCoA values, and then use the `Rel_corr_eig` column values (where rows are the Axis) as the proportion of variation explained by the axes because this column is the variance explained, corrected for negative eigenvalues

head(pcoa.asv)
```



```{r}
################################################################################
##          (a) Bray-Curtis b/w Host Species (Size = Diversity)
################################################################################

library(stringr)

# Create a modified version of the data with the updated species labels
pcoa.table_phenology_modified <- pcoa.table_phenology
pcoa.table_phenology_modified$Species <- str_replace_all(pcoa.table_phenology_modified$Species, "_", " ")

Phenology_beta_leaf <- ggplot(pcoa.table_phenology_modified, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(color = Species, size = alphaDiv), alpha = 0.85) +
  labs(title = paste0("Bray-Curtis Distance, size represents diversity"),
                      x = "Axis 1 [12.61%]",
                      y = "Axis 2 [10.38%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  theme(legend.position = "bottom", plot.title = element_text(size = 14)) +
  scale_custom_two

Phenology_beta_leaf + theme_cowplot(12)
```

```{r}
# Save the plot as a JPEG image
ggsave(filename = "Phenology_beta_shannon_species.jpeg", plot = Phenology_beta_leaf, device = "jpeg", width = 12, height = 6, units = "in")
```


```{r}
################################################################################
##(b) Bray-Curtis b/w Host Species (further differentiated by GDDs; Size = Diversity)
################################################################################

library(ggplot2)
library(dplyr)

# Exclude the value 323 from Growing-Degree-Days-5C
pcoa.table_phenology_filtered <- pcoa.table_phenology_modified %>%
  filter(GDD_5C != 323)

# Define the sampling points for GDD
sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

# Create a new categorical variable based on sampling points
pcoa.table_phenology_filtered$GDD_5C_bins <- cut(pcoa.table_phenology_filtered$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

# Define the custom shapes for each level of Growing-Degree-Days-5C
shapes <- c(21, 22, 23, 18, 8, 15, 17, 19)

Phenology_beta_gdd <- ggplot(pcoa.table_phenology_filtered, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(color = Species, size = alphaDiv, shape = GDD_5C_bins), alpha = 0.85) +
  labs(title = paste0("Bray-Curtis Distance (by Growing Degree Days (5C); size = Shannon Diversity)"),
       x = "Axis 1 [12.61%]",
       y = "Axis 2 [10.38%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  theme(legend.position = "bottom", plot.title = element_text(size = 20)) +
  scale_shape_manual(values = shapes) +
  labs(shape = "Growing Degree Days (5C)") +
  scale_custom_two

Phenology_beta_gdd + theme_cowplot(12)
```


```{r}
# Save the plot as a JPEG image
ggsave(filename = "Phenology_beta_shannon_gdd.jpeg", plot = Phenology_beta_gdd, device = "jpeg", width = 12, height = 6, units = "in")
```



```{r}
################################################################################
##(d) Bray-Curtis b/w Host Species (further differentiated by GDDs; Size = ASV Richness)
################################################################################

library(ggplot2)

# Define the sampling points for GDD
sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

# Create a new categorical variable based on sampling points
pcoa.table_phenology_filtered$GDD_5C_bins <- cut(pcoa.table_phenology_filtered$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

# Define the custom shapes for each unique GDD value
shapes <- c(21, 22, 23, 18, 8, 15, 17, 19)

Phenology_beta_asvgdd <- ggplot(pcoa.table_phenology_filtered, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(shape = GDD_5C_bins, color = Species, size = specnumber)) +
  labs(title = paste0("Bray-Curtis Distance (by Growing Degree Days (5C); size = ASV Richness)"),
       color = "Species", shape = "Growing Degree Days 5C",
       x = "Axis 1 [12.61%]",
       y = "Axis 2 [10.38%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  scale_shape_manual(values = shapes) +
  labs(shape = "Growing Degree Days 5C") +  # Update shape legend label
  scale_custom_two

Phenology_beta_asvgdd + theme_cowplot(12)
```

```{r}
# Save the plot as a JPEG image
ggsave(filename = "Phenology_beta_asvrich_gdd.jpeg", plot = Phenology_beta_asvgdd, device = "jpeg", width = 12, height = 6, units = "in")
```


```{r}
################################################################################
##(e) Bray-Curtis b/w Host Species (further differentiated by GDDs; NO SIZE
################################################################################

library(ggplot2)

# Define the sampling points for GDD
sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

# Create a new categorical variable based on sampling points
pcoa.table_phenology_filtered$GDD_5C_bins <- cut(pcoa.table_phenology_filtered$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

# Define the custom shapes for each unique GDD value
shapes <- c(21, 22, 23, 18, 8, 15, 17, 19)

Phenology_beta_nosize <- ggplot(pcoa.table_phenology_filtered, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(shape = GDD_5C_bins, color = Species), size = 5) +
  labs(title = paste0("Bray-Curtis Distance (by Growing Degree Days (5C)"),
       color = "Species", shape = "Growing Degree Days 5C",
       x = "Axis 1 [12.61%]",
       y = "Axis 2 [10.38%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  scale_shape_manual(values = shapes) +
  labs(shape = "Growing Degree Days 5C") +  # Update shape legend label
  scale_custom_two

Phenology_beta_nosize + theme_cowplot(12)
```

```{r}
# Save the plot as a JPEG image
ggsave(filename = "Phenology_beta_nosize.jpeg", plot = Phenology_beta_nosize, device = "jpeg", width = 12, height = 6, units = "in")
```


```{r}
################################################################################
# Calculate the percentage variance explained by each axis
################################################################################

# Perform CAP analysis
cap_result <- capscale(dist.mat ~ 1, data = pcoa.table_phenology)

# Extract percentage variance explained by each axis
percent_var_explained <- round(cap_result$CA$eig / sum(cap_result$CA$eig) * 100, 2)

# Print the results
print(percent_var_explained)
```


```{r}
#OR, another likely more valid way for PCoA is this, but they yield the same result essentially:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_inter <- pcoa.asv$values$Eigenvalues[1]
eigenvalues_axis2_inter <- pcoa.asv$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_inter <- sum(pcoa.asv$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_inter <- eigenvalues_axis1_inter / total_eigenvalues_inter * 100
variance_explained_axis2_inter <- eigenvalues_axis2_inter / total_eigenvalues_inter * 100

# Print the results
print(variance_explained_axis1_inter)
print(variance_explained_axis2_inter)
```



```{r}
################################################################################
## COMBINING PLOTS AS PANELS INTO RESPECTIVE FIGURES
################################################################################

library(gridExtra)

# Total Alpha Diversity (for sequencing QC):
beta_gdd_combined <- arrangeGrob(Phenology_beta_asvgdd, Phenology_beta_gdd, nrow=3)

ggsave("beta_gdd_combined.png", beta_gdd_combined, width=16, height=32)
```


```{r}
# Loop through each growing degree day and create a separate PCoA plot
for (gdd_value in unique(pcoa.table_phenology_filtered$GDD_5C)) {
  subset_data_pcoa <- subset(pcoa.table_phenology_filtered, GDD_5C == gdd_value)
  
  pcoa_plot_gdd <- ggplot(subset_data_pcoa, aes(x = Axis.1, y = Axis.2, color = Species, size = 3)) +
    geom_point(alpha = 0.85) +
    labs(
      title = paste("Bray-Curtis Distance - Growing Degree Days:", gdd_value),
      x = "Axis 1",
      y = "Axis 2"
    ) +
    theme(legend.position = "bottom", plot.title = element_text(size = 14))
  
  # Print each PCoA plot
  print(pcoa_plot_gdd)
}
```


```{r}
# Load the ggplot2 package if not already loaded

library(ggplot2)

# Set a directory to save the JPG files
beta_gdds <- "C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final"
dir.create(beta_gdds, showWarnings = FALSE)

# Loop through each growing degree day and create a separate PCoA plot
for (gdd_value in unique(pcoa.table_phenology_filtered$GDD_5C)) {
  subset_data_pcoa <- subset(pcoa.table_phenology_filtered, GDD_5C == gdd_value)
  
  pcoa_plot_gdd <- ggplot(subset_data_pcoa, aes(x = Axis.1, y = Axis.2, color = Species, size = 3)) +
    geom_point(alpha = 0.85) +
    labs(
      title = paste("Bray-Curtis Distance - Growing Degree Days:", gdd_value),
      x = "Axis 1",
      y = "Axis 2"
    ) +
    theme(legend.position = "bottom", plot.title = element_text(size = 14))
  
  # Define the filename based on the growing degree day value
  filename <- paste0(beta_gdds, "/pcoa_plot_gdd_", gdd_value, ".jpg")
  
  # Save each PCoA plot as a JPG file
  ggsave(filename, pcoa_plot_gdd, width = 8, height = 6, dpi = 300)
}
```



```{r}
library(gridExtra)
library(jpeg)

# Load your saved plots (replace "plot1.png", "plot2.png", etc., with your actual file names)
plot437 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_437.jpg"), interpolate=TRUE)
plot605 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_605.jpg"), interpolate=TRUE)
plot1087 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_1087.jpg"), interpolate=TRUE)
plot1606 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_1606.jpg"), interpolate=TRUE)
plot1992 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_1992.jpg"), interpolate=TRUE)
plot2140 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_2140.jpg"), interpolate=TRUE)
plot2219 <- rasterGrob(readJPEG("C:/Users/jwils/OneDrive/Documents/Grad_Studies/Microbial_Leaf_Spec_Project/microbe_data/MiSeq_data/MiSeq_16S/Phenology/FigsTables_Final/pcoa_plot_gdd_2219.jpg"), interpolate=TRUE)

# Arrange the plots in a grid
pcoas_gdd_combined <- arrangeGrob(plot437, plot605, plot1087, plot1606, plot1992, plot2140, plot2219, ncol=3, nrow=3)

# Save the combined plot
ggsave("pcoas_gdd_combined.png", pcoas_gdd_combined, width=12, height=8)  # Adjust width and height as needed
```



```{r}
################################################################################
# PERCENT VARIANCE EXPLAINED BY AXIS 1 & AXIS 2
################################################################################

data_437 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 437, ]
data_605 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 605, ]
data_1087 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 1087, ]
data_1606 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 1606, ]
data_1992 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 1992, ]
data_2140 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 2140, ]
data_2219 <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$GDD_5C == 2219, ]

################################################################################
# GDD_437
################################################################################

asv_437<-data_437[rowSums(data_437[,grepl("ASV", colnames(data_437))])!=0, ]
distance="bray"
dist.mat_437 <- vegan::vegdist(asv_437[,grepl("ASV", colnames(asv_437))], method = distance)
pcoa_437 <- pcoa(dist.mat_437)
pcoa.table_437 <- cbind(pcoa_437$vectors[, 1:5], asv_437[,!grepl("ASV", colnames(asv_437))])
pcoa.table_437$Axis.1

# Perform CAP analysis for GDD_5C value 437
cap_result_437 <- capscale(dist.mat_437 ~ 1, data = pcoa.table_437)

# Extract percentage variance explained by each axis
percent_var_explained_437 <- round(cap_result_437$CA$eig / sum(cap_result_437$CA$eig) * 100, 2)

# Print the results for GDD_5C value 437
print(percent_var_explained_437)


####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_437 <- pcoa_437$values$Eigenvalues[1]
eigenvalues_axis2_437 <- pcoa_437$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_437 <- sum(pcoa_437$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_437 <- eigenvalues_axis1_437 / total_eigenvalues_437 * 100
variance_explained_axis2_437 <- eigenvalues_axis2_437 / total_eigenvalues_437 * 100

# Print the results
print(variance_explained_axis1_437)
print(variance_explained_axis2_437)


################################################################################
# GDD_605
################################################################################

asv_605<-data_605[rowSums(data_605[,grepl("ASV", colnames(data_605))])!=0, ]
distance="bray"
dist.mat_605 <- vegan::vegdist(asv_605[,grepl("ASV", colnames(asv_605))], method = distance)
pcoa_605 <- pcoa(dist.mat_605)
pcoa.table_605 <- cbind(pcoa_605$vectors[, 1:5], asv_605[,!grepl("ASV", colnames(asv_605))])
pcoa.table_605$Axis.1

# Perform CAP analysis for GDD_5C value 605
cap_result_605 <- capscale(dist.mat_605 ~ 1, data = pcoa.table_605)

# Extract percentage variance explained by each axis
percent_var_explained_605 <- round(cap_result_605$CA$eig / sum(cap_result_605$CA$eig) * 100, 2)

# Print the results for GDD_5C value 605
print(percent_var_explained_605)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_605 <- pcoa_605$values$Eigenvalues[1]
eigenvalues_axis2_605 <- pcoa_605$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_605 <- sum(pcoa_605$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_605 <- eigenvalues_axis1_605 / total_eigenvalues_605 * 100
variance_explained_axis2_605 <- eigenvalues_axis2_605 / total_eigenvalues_605 * 100

# Print the results
print(variance_explained_axis1_605)
print(variance_explained_axis2_605)

################################################################################
# GDD_1087
################################################################################

asv_1087<-data_1087[rowSums(data_1087[,grepl("ASV", colnames(data_1087))])!=0, ]
distance="bray"
dist.mat_1087 <- vegan::vegdist(asv_1087[,grepl("ASV", colnames(asv_1087))], method = distance)
pcoa_1087 <- pcoa(dist.mat_1087)
pcoa.table_1087 <- cbind(pcoa_1087$vectors[, 1:5], asv_1087[,!grepl("ASV", colnames(asv_1087))])
pcoa.table_1087$Axis.1

# Perform CAP analysis for GDD_5C value 1087
cap_result_1087 <- capscale(dist.mat_1087 ~ 1, data = pcoa.table_1087)

# Extract percentage variance explained by each axis
percent_var_explained_1087 <- round(cap_result_1087$CA$eig / sum(cap_result_1087$CA$eig) * 100, 2)

# Print the results for GDD_5C value 1087
print(percent_var_explained_1087)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_1087 <- pcoa_1087$values$Eigenvalues[1]
eigenvalues_axis2_1087 <- pcoa_1087$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_1087 <- sum(pcoa_1087$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_1087 <- eigenvalues_axis1_1087 / total_eigenvalues_1087 * 100
variance_explained_axis2_1087 <- eigenvalues_axis2_1087 / total_eigenvalues_1087 * 100

# Print the results
print(variance_explained_axis1_1087)
print(variance_explained_axis2_1087)

################################################################################
# GDD_1606
################################################################################

asv_1606<-data_1606[rowSums(data_1606[,grepl("ASV", colnames(data_1606))])!=0, ]
distance="bray"
dist.mat_1606 <- vegan::vegdist(asv_1606[,grepl("ASV", colnames(asv_1606))], method = distance)
pcoa_1606 <- pcoa(dist.mat_1606)
pcoa.table_1606 <- cbind(pcoa_1606$vectors[, 1:5], asv_1606[,!grepl("ASV", colnames(asv_1606))])
pcoa.table_1606$Axis.1

# Perform CAP analysis for GDD_5C value 1087
cap_result_1606 <- capscale(dist.mat_1606 ~ 1, data = pcoa.table_1606)

# Extract percentage variance explained by each axis
percent_var_explained_1606 <- round(cap_result_1606$CA$eig / sum(cap_result_1606$CA$eig) * 100, 2)

# Print the results for GDD_5C value 1087
print(percent_var_explained_1606)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_1606 <- pcoa_1606$values$Eigenvalues[1]
eigenvalues_axis2_1606 <- pcoa_1606$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_1606 <- sum(pcoa_1606$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_1606 <- eigenvalues_axis1_1606 / total_eigenvalues_1606 * 100
variance_explained_axis2_1606 <- eigenvalues_axis2_1606 / total_eigenvalues_1606 * 100

# Print the results
print(variance_explained_axis1_1606)
print(variance_explained_axis2_1606)

################################################################################
# GDD_1992
################################################################################

asv_1992<-data_1992[rowSums(data_1992[,grepl("ASV", colnames(data_1992))])!=0, ]
distance="bray"
dist.mat_1992 <- vegan::vegdist(asv_1992[,grepl("ASV", colnames(asv_1992))], method = distance)
pcoa_1992 <- pcoa(dist.mat_1992)
pcoa.table_1992 <- cbind(pcoa_1992$vectors[, 1:5], asv_1992[,!grepl("ASV", colnames(asv_1992))])
pcoa.table_1992$Axis.1

# Perform CAP analysis for GDD_5C value 1087
cap_result_1992 <- capscale(dist.mat_1992 ~ 1, data = pcoa.table_1992)

# Extract percentage variance explained by each axis
percent_var_explained_1992 <- round(cap_result_1992$CA$eig / sum(cap_result_1992$CA$eig) * 100, 2)

# Print the results for GDD_5C value 1087
print(percent_var_explained_1992)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_1992 <- pcoa_1992$values$Eigenvalues[1]
eigenvalues_axis2_1992 <- pcoa_1992$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_1992 <- sum(pcoa_1992$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_1992 <- eigenvalues_axis1_1992 / total_eigenvalues_1992 * 100
variance_explained_axis2_1992 <- eigenvalues_axis2_1992 / total_eigenvalues_1992 * 100

# Print the results
print(variance_explained_axis1_1992)
print(variance_explained_axis2_1992)

################################################################################
# GDD_2140
################################################################################

asv_2140<-data_2140[rowSums(data_2140[,grepl("ASV", colnames(data_2140))])!=0, ]
distance="bray"
dist.mat_2140 <- vegan::vegdist(asv_2140[,grepl("ASV", colnames(asv_2140))], method = distance)
pcoa_2140 <- pcoa(dist.mat_2140)
pcoa.table_2140 <- cbind(pcoa_2140$vectors[, 1:5], asv_2140[,!grepl("ASV", colnames(asv_2140))])
pcoa.table_2140$Axis.1

# Perform CAP analysis for GDD_5C value 1087
cap_result_2140 <- capscale(dist.mat_2140 ~ 1, data = pcoa.table_2140)

# Extract percentage variance explained by each axis
percent_var_explained_2140 <- round(cap_result_2140$CA$eig / sum(cap_result_2140$CA$eig) * 100, 2)

# Print the results for GDD_5C value 1087
print(percent_var_explained_2140)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_2140 <- pcoa_2140$values$Eigenvalues[1]
eigenvalues_axis2_2140 <- pcoa_2140$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_2140 <- sum(pcoa_2140$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_2140 <- eigenvalues_axis1_2140 / total_eigenvalues_2140 * 100
variance_explained_axis2_2140 <- eigenvalues_axis2_2140 / total_eigenvalues_2140 * 100

# Print the results
print(variance_explained_axis1_2140)
print(variance_explained_axis2_2140)

################################################################################
# GDD_2219
################################################################################

asv_2219<-data_2219[rowSums(data_2219[,grepl("ASV", colnames(data_2219))])!=0, ]
distance="bray"
dist.mat_2219 <- vegan::vegdist(asv_2219[,grepl("ASV", colnames(asv_2219))], method = distance)
pcoa_2219 <- pcoa(dist.mat_2219)
pcoa.table_2219 <- cbind(pcoa_2219$vectors[, 1:5], asv_2219[,!grepl("ASV", colnames(asv_2219))])
pcoa.table_2219$Axis.1

# Perform CAP analysis for GDD_5C value 1087
cap_result_2219 <- capscale(dist.mat_2219 ~ 1, data = pcoa.table_2219)

# Extract percentage variance explained by each axis
percent_var_explained_2219 <- round(cap_result_2219$CA$eig / sum(cap_result_2219$CA$eig) * 100, 2)

# Print the results for GDD_5C value 1087
print(percent_var_explained_2219)

####OR:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_2219 <- pcoa_2219$values$Eigenvalues[1]
eigenvalues_axis2_2219 <- pcoa_2219$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_2219 <- sum(pcoa_2219$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_2219 <- eigenvalues_axis1_2219 / total_eigenvalues_2219 * 100
variance_explained_axis2_2219 <- eigenvalues_axis2_2219 / total_eigenvalues_2219 * 100

# Print the results
print(variance_explained_axis1_2219)
print(variance_explained_axis2_2219)
```




################################################################################
## BETA DIVERSITY (INTRASPECIFIC)
################################################################################

```{r}
library(ggforce)

# Does community composition cluster based on GDD within each species?

pcoa_betula_subset <- pcoa.table_phenology_modified[pcoa.table_phenology_modified$Species == "Betula populifolia", ]
pcoa_populus_subset <- pcoa.table_phenology_modified[pcoa.table_phenology_modified$Species == "Populus tremuloides", ]

scale_custom_9 <- list(
      scale_color_manual(values = c("purple","darkred","darkblue", "turquoise","darkorange","darkgreen","magenta", "gold")),
      scale_fill_manual(values = c("purple","darkred","darkblue", "turquoise","darkorange","darkgreen","magenta", "gold" ))
)

###################################################################
#Betula:
###################################################################

data_betula <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Betula_populifolia", ]

asv_betula<-data_betula[rowSums(data_betula[,grepl("ASV", colnames(data_betula))])!=0, ]
distance="bray"
dist.mat_betula <- vegan::vegdist(asv_betula[,grepl("ASV", colnames(asv_betula))], method = distance)
pcoa_betula <- pcoa(dist.mat_betula)
pcoa.table_betula <- cbind(pcoa_betula$vectors[, 1:5], asv_betula[,!grepl("ASV", colnames(asv_betula))])
pcoa.table_betula$Axis.1

# Define the sampling points for GDD
sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

# Create a new categorical variable based on sampling points
pcoa_betula_subset$GDD_5C_bins <- cut(pcoa_betula_subset$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

# Define the custom shapes for each unique GDD value
shapes <- c(21, 22, 23, 18, 8, 15, 17, 19)

betula_pcoa_plot <- ggplot(pcoa_betula_subset, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(color = GDD_5C_bins, size = 3)) +
  labs(title = paste0("Bray-Curtis Distance (Betula populifolia)"),
       color = "Growing Degree Days (5\u00B0C)",
       x = "Axis 1 [25.99%]", y = "Axis 2 [11.26%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  scale_custom_9

betula_pcoa_plot + theme_cowplot(12)
```


```{r}
# CAP Analysis for percent variance

cap_result_betula <- capscale(dist.mat_betula ~ 1, data = pcoa.table_betula)

percent_var_explained_betula <- round(cap_result_betula$CA$eig / sum(cap_result_betula$CA$eig) * 100, 2)

print(percent_var_explained_betula)

#OR, likely better for PCoA:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_betula <- pcoa_betula$values$Eigenvalues[1]
eigenvalues_axis2_betula <- pcoa_betula$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_betula <- sum(pcoa_betula$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_betula <- eigenvalues_axis1_betula / total_eigenvalues_betula * 100
variance_explained_axis2_betula <- eigenvalues_axis2_betula / total_eigenvalues_betula * 100

# Print the results
print(variance_explained_axis1_betula)
print(variance_explained_axis2_betula)
```


```{r}
# Save the plot as a JPEG image
ggsave(filename = "Betula_pcoa_gdds.jpeg", plot = betula_pcoa_plot, device = "jpeg", width = 12, height = 8, units = "in")
```


```{r}
###################################################################
#Populus:
###################################################################

data_populus <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Populus_tremuloides", ]

asv_populus<-data_populus[rowSums(data_populus[,grepl("ASV", colnames(data_populus))])!=0, ]
distance="bray"
dist.mat_populus <- vegan::vegdist(asv_populus[,grepl("ASV", colnames(asv_populus))], method = distance)
pcoa_populus <- pcoa(dist.mat_populus)
pcoa.table_populus <- cbind(pcoa_populus$vectors[, 1:5], asv_populus[,!grepl("ASV", colnames(asv_populus))])
pcoa.table_populus$Axis.1

# Define the sampling points for GDD
sampling_points <- c(437, 605, 1087, 1606, 1992, 2140, 2219)

# Create a new categorical variable based on sampling points
pcoa_populus_subset$GDD_5C_bins <- cut(pcoa_populus_subset$GDD_5C,
  breaks = c(-Inf, sampling_points, Inf),
  labels = c("437", "605", "1087", "1606", "1992", "2140", "2219", "2220+"),
  include.lowest = TRUE
)

# Define the custom shapes for each unique GDD value
shapes <- c(21, 22, 23, 18, 8, 15, 17, 19)

populus_pcoa_plot <- ggplot(pcoa_populus_subset, aes(x = Axis.1, y = Axis.2)) +
  geom_point(aes(color = GDD_5C_bins, size = 3)) +
  labs(title = paste0("Bray-Curtis Distance (Populus tremuloides"),
       color = "Growing Degree Days (5\u00B0C)",
       x = "Axis 1 [7.54%]", y = "Axis 2 [5.96%]") +
  guides(color = guide_legend(override.aes = list(alpha = 1))) +
  scale_custom_9

populus_pcoa_plot + theme_cowplot(12)
```


```{r}
# CAP Analysis for percent variance

cap_result_populus <- capscale(dist.mat_populus ~ 1, data = pcoa.table_populus)

percent_var_explained_populus <- round(cap_result_populus$CA$eig / sum(cap_result_populus$CA$eig) * 100, 2)

print(percent_var_explained_populus)

#OR, likely better for PCoA:

# Extract eigenvalues for Axis 1 and Axis 2
eigenvalues_axis1_populus <- pcoa_populus$values$Eigenvalues[1]
eigenvalues_axis2_populus <- pcoa_populus$values$Eigenvalues[2]

# Calculate the total sum of eigenvalues for normalization
total_eigenvalues_populus <- sum(pcoa_populus$values$Eigenvalues)

# Calculate the percentage of variance explained by Axis 1 and Axis 2
variance_explained_axis1_populus <- eigenvalues_axis1_populus / total_eigenvalues_populus * 100
variance_explained_axis2_populus <- eigenvalues_axis2_populus / total_eigenvalues_populus * 100

# Print the results
print(variance_explained_axis1_populus)
print(variance_explained_axis2_populus)
```



```{r}
# Save the plot as a JPEG image
ggsave(filename = "Populus_pcoa_gdds.jpeg", plot = populus_pcoa_plot, device = "jpeg", width = 12, height = 8, units = "in")
```


```{r}
# Save `asv_scaled_noPlants_Phen_filt_LMM`
write.csv(asv_scaled_noPlants_Phen_filt_LMM, file = "asv_scaled_noPlants_Phen_filt_LMM.csv", row.names = FALSE)
```





################################################################################
##                   16S TAXONOMIC ABUNDANCES & COMPOSITIONS
################################################################################

```{r}
tx<-as.data.frame(taxa_rdp[rownames(taxa_rdp) %in% colnames(asv_scaled_noPlants_Phen_filt_LMM),])
head(tx)
```

```{r, tidy=TRUE}
taxaLevel="Genus"
asv_data=asv_scaled_noPlants_Phen_filt_LMM
asv_data$Species <- as.character(asv_data$Species)

stackedBarPlots<-lapply(c("Genus", "Order", "Phylum"), function(taxaLevel){
  asvList<-colnames(asv_data)[grepl("ASV",colnames(asv_data))]
  tx$asv<-rownames(tx)
  asvSub<-asv_data[, c("Species", colnames(asv_data)[grepl("ASV",colnames(asv_data))])]

  m<-as.matrix(asvSub[,-c(1)])
  m2<-do.call(rbind,lapply(1:nrow(m), function(i) {m[i,]/sum(m[i,]) }))
  asvSub2<-cbind(asvSub[,c(1)], m2)
  colnames(asvSub2)[1]<-"Species"
  asvSub2<-as.data.frame(asvSub2)
  asvSub2[2:ncol(asvSub2)]<-lapply(asvSub2[2:ncol(asvSub2)], as.numeric)
  x<-split(asvSub2, ~Species,drop=T)
  asv_ag<-cbind(data.frame(Species=names(x),
                do.call(rbind,lapply(x, function(xi) colSums(xi[,2:ncol(xi)])))))

  #* `Start finding N reads: `
  x_nreads<-split(asvSub, ~Species,drop=T)
  asv_ag_nreads<-cbind(data.frame(Species=names(x),
                do.call(rbind,lapply(x_nreads, function(xi) colSums(xi[,2:ncol(xi)])))))
  test_nreads<-as.data.frame(t(asv_ag_nreads[,-c(1:2)]))
  test_nreads$asv<-rownames(test_nreads)
  test_nreads$taxa<-unlist(lapply(test_nreads$asv, function(a) tx[tx$asv==a, taxaLevel]))
  test_nreads$taxa<-replace(test_nreads$taxa, is.na(test_nreads$taxa), "Not Assigned")
  test_nreads<-test_nreads[,-c(3)]
  testag_nreads<-aggregate(.~taxa, test_nreads, sum,na.rm=T) # may transform to relative abundance per sample first?
  tab<-colSums(testag_nreads[,2:3])
  tab<-tab[sort(names(tab))]
  #* `End making N reads: `
  
  test<-as.data.frame(t(asv_ag[,-c(1)]))
  test$asv<-rownames(test)
  test$taxa<-unlist(lapply(test$asv, function(a) tx[tx$asv==a, taxaLevel]))
  test$taxa<-replace(test$taxa, is.na(test$taxa), "Not Assigned")
  test<-test[,-c(3)]
  testag<-aggregate(.~taxa, test, sum,na.rm=T) # may transform to relative abundance per sample first?
  tab_ntaxa<-sapply(testag[,c(2:ncol(testag))], function(i){sum(i!=0)})
  tab_ntaxa<-tab_ntaxa[sort(names(tab_ntaxa))]
  tab_ntaxa
  # tab<-colSums(testag[,2:7])
  # tab<-tab[sort(names(tab))]
  pct<-testag
  pct[,2:ncol(pct)]<-lapply(pct[,2:ncol(pct)], function(c) c/sum(c))
  longpct<-as.data.frame(tidyr::pivot_longer(pct, cols=2:ncol(pct)))
  longpct$name<-factor(longpct$name, levels =sort(unique(longpct$name)), ordered=T)
  
  taxaPctPlot<-ggplot(longpct, aes(x=str_replace(name, "[.]", "\n"), y=value,fill=taxa))+
    geom_col(width=0.99)+
    viridis::scale_fill_viridis(discrete=T,option="viridis")+
    scale_y_continuous(labels=scales::percent_format())+
    scale_x_discrete(labels=~paste0(., "\n ",paste(tab, tab_ntaxa, sep=" Reads\n"), " Taxa"))+
    labs(y=paste0("Percentage In ",taxaLevel), fill = taxaLevel)+
    theme(axis.title.x=element_blank())
  
  if(length(unique(longpct$taxa))<50){
    taxaPctPlot<-taxaPctPlot+
      guides(fill = guide_legend(nrow=ceiling(length(unique(longpct$taxa))/7),byrow=F, label.theme=element_text(size=6.5), keyheight = 0.5), title=taxaLevel)+
      theme(legend.position="bottom")
  } else{taxaPctPlot<-taxaPctPlot+theme(legend.position="left")}
  
  print(taxaPctPlot)
ggsave(filename = paste0("taxaPctPlot",taxaLevel,".jpg"), taxaPctPlot, device="jpg",width=34,height=6)

  faceted<-ggplot(longpct, aes(x=paste0(str_replace(gsub(".*[.]","",name), "[.]", "\n"), "\n ",paste(tab, tab_ntaxa, sep=" Reads\n"), " Taxa"), y=value,fill=taxa))+
    facet_wrap(~name, scales="free_x")+
    geom_col(width=0.99)+
    viridis::scale_fill_viridis(discrete=T,option="viridis")+ #Change colour
    scale_y_continuous(labels=scales::percent_format())+
    labs(y=paste0("Percentage In ",taxaLevel), fill = taxaLevel)+
    theme(axis.title.x=element_blank())
  
  if(length(unique(longpct$taxa))<50){
    faceted<-faceted+
      guides(fill = guide_legend(nrow=ceiling(length(unique(longpct$taxa))/7),byrow=F, label.theme=element_text(size=6.5), keyheight = 0.5), title=taxaLevel)+
      theme(legend.position="bottom")
  } else{faceted<-faceted+theme(legend.position="none")}
  
  print(faceted)
  ggsave(filename = paste0("faceted_taxaPctPlot",taxaLevel,".jpg"), faceted, device="jpg",width=11,height=5)
  return(list("nofacet" = taxaPctPlot, "faceted"=faceted, "longdata" = longpct, "d"=test))
})
```


```{r}
# Filter data by species
data_betula <- subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia")
data_populus <- subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides")
```


###############################################################################
## Phyloseq Statistics???
###############################################################################


Here, I make a `phyloseq` object, even though I generally did not use this package. My data structure didn't really feed into the `phyloseq` functions well, so I had to do some tweaks to the data structures to make the object. Hopefully, this has been done correctly...

I did this in order to perform the above, but across GDDs, AND to do Differential Taxa Abundance Analysis using `DESeq2` later on. 

```{r}
library(phyloseq)

#--------------------------------------------------
# FOR `asv_scaled_noPlants_Phenology_filtered`:
#--------------------------------------------------

#tx_data <- as.data.frame(tx)

meta_stats <- data.frame(meta)
asv_scaled_noPlants_Phenology_stats <- data.frame(asv_scaled_noPlants_Phenology_filtered)

# Add the "_R1_F_filt.fastq" suffix to the "Name" column to create the "SampleID" column
meta_stats$SampleID <- paste0(meta_stats$Name, "_R1_F_filt.fastq")
asv_scaled_noPlants_Phenology_stats$SampleID <- paste0(asv_scaled_noPlants_Phenology_stats$Name, "_R1_F_filt.fastq")

# Set the "SampleID" column as the row names of the meta_stats data frame
rownames(meta_stats) <- meta_stats$SampleID
rownames(asv_scaled_noPlants_Phenology_stats) <- asv_scaled_noPlants_Phenology_stats$SampleID

# Remove the "SampleID" column since it is now used as row names
# meta_stats$SampleID <- NULL
# asv_scaled_noPlants_Phenology_stats$SampleID <- NULL

#--------------------------------------------------
# FOR `asv_scaled_noPlants_Phen_filt_LMM`:
#--------------------------------------------------

#tx_data <- as.data.frame(tx)

meta_stats <- data.frame(meta)
asv_scaled_noPlants_Phenology_stats_LMM <- data.frame(asv_scaled_noPlants_Phen_filt_LMM)

# Add the "_R1_F_filt.fastq" suffix to the "Name" column to create the "SampleID" column
meta_stats$SampleID <- paste0(meta_stats$Name, "_R1_F_filt.fastq")
asv_scaled_noPlants_Phenology_stats_LMM$SampleID <- paste0(asv_scaled_noPlants_Phenology_stats_LMM$Name, "_R1_F_filt.fastq")

# Set the "SampleID" column as the row names of the meta_stats data frame
rownames(meta_stats) <- meta_stats$SampleID
rownames(asv_scaled_noPlants_Phenology_stats_LMM) <- asv_scaled_noPlants_Phenology_stats_LMM$SampleID

# Remove the "SampleID" column since it is now used as row names
# meta_stats$SampleID <- NULL
# asv_scaled_noPlants_Phenology_stats$SampleID <- NULL

# Copy the numeric 'GDD_5C' column to a new factor 'GDD_5C_categ' column
asv_scaled_noPlants_Phen_filt_LMM$GDD_5C_categ <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$GDD_5C)


taxaMat <- as.matrix(tx)

# Create `phyloseq` object (with `meta_stats`)
ps_phen <- phyloseq(otu_table(seqtab.print, taxa_are_rows=FALSE), 
               sample_data(meta_stats), 
               tax_table(taxaMat))

# Create `phyloseq` object (with `asv_scaled_noPlants_Phenology_stats`)
ps_phen_asv <- phyloseq(otu_table(seqtab.print, taxa_are_rows=FALSE), 
               sample_data(asv_scaled_noPlants_Phenology_stats), 
               tax_table(taxaMat))

ps_phen_asv_LMM <- phyloseq(otu_table(seqtab.print, taxa_are_rows=FALSE), 
               sample_data(asv_scaled_noPlants_Phenology_stats_LMM), 
               tax_table(taxaMat))

```


```{r}
################################################################################
## BOTH SPECIES COMBINED/OVERALL VIEW
################################################################################

ps_phyla <- tax_glom(ps_phen_asv_LMM, "Phylum")
ps0_phyla <- transform_sample_counts(ps_phyla, function(x) x / sum(x))
ps1_phyla <- merge_samples(ps0_phyla, "GDD_5C_bins")
ps2_phyla <- transform_sample_counts(ps1_phyla, function(x) x / sum(x))

# Create a bar plot
combined_composition_gdd_phyla <- plot_bar(ps2_phyla, x = "GDD_5C_bins", fill = "Phylum") +
  labs(title = "Combined Taxonomic Abundance", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance")

# Print the bar plot
print(combined_composition_gdd_phyla)
```




```{r}
library(phyloseq)
library(ggplot2)

################################################################################
# BETULA PHYLA (ACROSS GDDs)
################################################################################

# Subset the phyloseq object for Betula_populifolia
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

# Create a bar plot for Betula_populifolia
betula_composition_gdd_phyla <- plot_bar(subset_ps_betula, x = "GDD_5C_bins", fill = "Phylum") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)")

betula_composition_gdd_phyla

# Adjust the plot dimensions and margins
#betula_composition +
#  theme(legend.position = "bottom") +  # Move the legend to the right
#  theme(legend.box.margin = margin(1, 1, 1, 1, "cm")) +  # Expand legend margin
#  theme(legend.box.background = element_rect(color = "black", linewidth = 0.5)) +  # Add a border to the legend
#  theme(legend.spacing.y = unit(0.25, "cm")) +  # Adjust vertical spacing in the legend
#  theme(legend.key.size = unit(0.5, "cm"))  # Adjust the size of legend keys
```

```{r}
ggsave("betula_comp_gdd_phyla.png", plot = betula_composition_gdd_phyla, width = 10, height = 6, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

ps_bet_phy <- tax_glom(subset_ps_betula, "Phylum")
ps0_bet_phy <- transform_sample_counts(ps_bet_phy, function(x) x / sum(x))
ps1_bet_phy <- merge_samples(ps0_bet_phy, "GDD_5C_bins")
ps2_bet_phy <- transform_sample_counts(ps1_bet_phy, function(x) x / sum(x))

# Create a bar plot
betula_composition_gdd_phyla2 <- plot_bar(ps2_bet_phy, x = "GDD_5C_bins", fill = "Phylum") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance")

# Print the bar plot
print(betula_composition_gdd_phyla2)
```


```{r}
ggsave("betula_comp_gdd_phyla2.png", plot = betula_composition_gdd_phyla2, width = 10, height = 6, units = "in", dpi = 300)
```


```{r}
################################################################################
# BETULA ORDERS (ACROSS GDDs)
################################################################################

# Subset the phyloseq object for Betula_populifolia
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

# Create a bar plot for Betula_populifolia
betula_composition_gdd_order <- plot_bar(subset_ps_betula, x = "GDD_5C_bins", fill = "Order") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)")

betula_composition_gdd_order
```

```{r}
ggsave("betula_comp_gdd_order.png", plot = betula_composition_gdd_order, width = 18, height = 14, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

ps_bet_ord <- tax_glom(subset_ps_betula, "Order")
ps0_bet_ord <- transform_sample_counts(ps_bet_ord, function(x) x / sum(x))
ps1_bet_ord <- merge_samples(ps0_bet_ord, "GDD_5C_bins")
ps2_bet_ord <- transform_sample_counts(ps1_bet_ord, function(x) x / sum(x))

# Create a bar plot
betula_composition_gdd_order2 <- plot_bar(ps2_bet_ord, x = "GDD_5C_bins", fill = "Order") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance")

# Print the bar plot
print(betula_composition_gdd_order2)
```

```{r}
ggsave("betula_comp_gdd_order2.png", plot = betula_composition_gdd_order2, width = 24, height = 14, units = "in", dpi = 300)
```


```{r}
################################################################################
# BETULA FAMILIESS (ACROSS GDDs)
################################################################################

# Subset the phyloseq object for Betula_populifolia
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

# Create a bar plot for Betula_populifolia
betula_composition_gdd_fam <- plot_bar(subset_ps_betula, x = "GDD_5C_bins", fill = "Family") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)")

betula_composition_gdd_fam
```

```{r}
ggsave("betula_comp_gdd_fam.png", plot = betula_composition_gdd_fam, width = 18, height = 14, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

ps_bet_fam <- tax_glom(subset_ps_betula, "Family")
ps0_bet_fam <- transform_sample_counts(ps_bet_fam, function(x) x / sum(x))
ps1_bet_fam <- merge_samples(ps0_bet_fam, "GDD_5C_bins")
ps2_bet_fam <- transform_sample_counts(ps1_bet_fam, function(x) x / sum(x))

# Create a bar plot
betula_composition_gdd_fam2 <- plot_bar(ps2_bet_fam, x = "GDD_5C_bins", fill = "Family", facet_grid = ~Phylum) +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance") +
  theme(legend.position = "bottom")

# Print the bar plot
print(betula_composition_gdd_fam2)
```




```{r}
ggsave("betula_comp_gdd_fam2.png", plot = betula_composition_gdd_fam2, width = 18, height = 14, units = "in", dpi = 300)
```



```{r}
################################################################################
# BETULA GENERA (ACROSS GDDs)
################################################################################

# Create the bar plot for Betula_populifolia
betula_composition_gdd <- plot_bar(subset_ps_betula, x = "GDD_5C_bins", fill = "Genus") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)")

# Save the plot without the legend
ggsave("betula_comp_gdd_plot_sp.png", plot = betula_composition_gdd + theme(legend.position = "none"), width = 12, height = 8, units = "in", dpi = 300)

# Save the legend separately
legend_gdd_betula <- get_legend(betula_composition_gdd)
ggsave("betula_comp_gdd_legend_sp.png", legend_gdd_betula, width = 34, height = 5.5, units = "in", dpi = 300)
```



```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_betula <- subset_samples(ps_phen_asv_LMM, Species == "Betula_populifolia")

ps_bet_gen <- tax_glom(subset_ps_betula, "Genus")
ps0_bet_gen <- transform_sample_counts(ps_bet_gen, function(x) x / sum(x))
ps1_bet_gen <- merge_samples(ps0_bet_gen, "GDD_5C_bins")
ps2_bet_gen <- transform_sample_counts(ps1_bet_gen, function(x) x / sum(x))

# Create a bar plot
betula_composition_gdd_gen <- plot_bar(ps2_bet_gen, x = "GDD_5C_bins", fill = "Genus") +
  labs(title = "Taxonomic Abundance for Betula populifolia", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance") +
  theme(legend.position = "bottom")

# Print the bar plot
print(betula_composition_gdd_gen)
```


```{r}
ggsave("betula_comp_gdd_gen.png", plot = betula_composition_gdd_gen, width = 24, height = 20, units = "in", dpi = 300)
```



```{r}
library(phyloseq)
library(ggplot2)

################################################################################
# POPULUS PHYLA (ACROSS GDDs)
################################################################################

# Subset the phyloseq object for Betula_populifolia
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

# Create a bar plot for Betula_populifolia
populus_composition_gdd_phyla <- plot_bar(subset_ps_populus, x = "GDD_5C_bins", fill = "Phylum") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5\u00B0C)")

populus_composition_gdd_phyla
```

```{r}
ggsave("populus_comp_gdd_phyla.png", plot = populus_composition_gdd_phyla, width = 10, height = 6, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

ps_pop_phy <- tax_glom(subset_ps_populus, "Phylum")
ps0_pop_phy <- transform_sample_counts(ps_pop_phy, function(x) x / sum(x))
ps1_pop_phy <- merge_samples(ps0_pop_phy, "GDD_5C_bins")
ps2_pop_phy <- transform_sample_counts(ps1_pop_phy, function(x) x / sum(x))

# Create a bar plot
populus_composition_gdd_phyla2 <- plot_bar(ps2_pop_phy, x = "GDD_5C_bins", fill = "Phylum") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5\u00B0C)", y = "% Relative Abundance")

# Print the bar plot
print(populus_composition_gdd_phyla2)
```

```{r}
ggsave("populus_composition_gdd_phyla2.png", plot = populus_composition_gdd_phyla2, width = 10, height = 6, units = "in", dpi = 300)
```


```{r}
################################################################################
# POPULUS ORDERS (ACROSS GDDs)
################################################################################

# Subset the phyloseq object for Populus_tremuloides
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

# Create a bar plot for Populus_tremuloides
populus_composition_gdd_order <- plot_bar(subset_ps_populus, x = "GDD_5C_bins", fill = "Order") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5C)")

populus_composition_gdd_order
```


```{r}
ggsave("populus_comp_gdd_order.png", plot = populus_composition_gdd_order, width = 18, height = 14, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

ps_pop_ord <- tax_glom(subset_ps_populus, "Order")
ps0_pop_ord <- transform_sample_counts(ps_pop_ord, function(x) x / sum(x))
ps1_pop_ord <- merge_samples(ps0_pop_ord, "GDD_5C_bins")
ps2_pop_ord <- transform_sample_counts(ps1_pop_ord, function(x) x / sum(x))

# Create a bar plot
populus_composition_gdd_ord <- plot_bar(ps2_pop_ord, x = "GDD_5C_bins", fill = "Order") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5C)", y = "% Relative Abundance")

# Print the bar plot
print(populus_composition_gdd_ord)
```


```{r}
################################################################################
## POPULUS FAMILIES (ACROSS GDDs)
################################################################################

# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

ps_pop_fam <- tax_glom(subset_ps_populus, "Family")
ps0_pop_fam <- transform_sample_counts(ps_pop_fam, function(x) x / sum(x))
ps1_pop_fam <- merge_samples(ps0_pop_fam, "GDD_5C_bins")
ps2_pop_fam <- transform_sample_counts(ps1_pop_fam, function(x) x / sum(x))

# Create a bar plot
populus_composition_gdd_fam <- plot_bar(ps2_pop_fam, x = "GDD_5C_bins", fill = "Family") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5C)", y = "% Relative Abundance") +
  theme(legend.position = "bottom")

# Print the bar plot
print(populus_composition_gdd_fam)
```


```{r}
ggsave("populus_comp_gdd_fam.png", plot = populus_composition_gdd_fam, width = 18, height = 14, units = "in", dpi = 300)
```


```{r}
################################################################################
# POPULUS GENERA (ACROSS GDDs)
################################################################################

# Create the bar plot for Betula_populifolia
populus_composition_gdd <- plot_bar(subset_ps_populus, x = "GDD_5C_bins", fill = "Genus") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5C)")

# Save the plot without the legend
ggsave("populus_comp_gdd_plot_sp.png", plot = populus_composition_gdd + theme(legend.position = "none"), width = 12, height = 8, units = "in", dpi = 300)

# Save the legend separately
legend_gdd_populus <- get_legend(populus_composition_gdd)
ggsave("populus_comp_gdd_legend_sp.png", legend_gdd_populus, width = 34, height = 5.5, units = "in", dpi = 300)
```


```{r}
# Assuming GDD_5C is a numeric variable in your sample data
subset_ps_populus <- subset_samples(ps_phen_asv_LMM, Species == "Populus_tremuloides")

ps_pop_gen <- tax_glom(subset_ps_populus, "Genus")
ps0_pop_gen <- transform_sample_counts(ps_pop_gen, function(x) x / sum(x))
ps1_pop_gen <- merge_samples(ps0_pop_gen, "GDD_5C_bins")
ps2_pop_gen <- transform_sample_counts(ps1_pop_gen, function(x) x / sum(x))

# Create a bar plot
populus_composition_gdd_gen <- plot_bar(ps2_pop_gen, x = "GDD_5C_bins", fill = "Genus") +
  labs(title = "Taxonomic Abundance for Populus tremuloides", x = "Growing Degree Days (5C)", y = "% Relative Abundance") +
  theme(legend.position = "bottom")

# Print the bar plot
print(populus_composition_gdd_gen)
```


```{r}
ggsave("populus_comp_gdd_gen.png", plot = populus_composition_gdd_gen, width = 18, height = 14, units = "in", dpi = 300)
```


```{r}
ex <- stackedBarPlots[[3]]$d # Choose level of taxono
ex_l <- tidyr::pivot_longer(ex, cols = c("Betula_populifolia", "Populus_tremuloides"))

ggplot(ex_l, aes(x = taxa, y = value, fill = name)) +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Taxa", y = "Value", fill = "Species") +
  scale_fill_manual(values = c("Betula_populifolia" = "#ecb21e", "Populus_tremuloides" = "#812e91"))
```


```{r, warning=FALSE}
# Create the plot with logarithmic y-axis scale
ggplot(ex_l, aes(x = taxa, y = value, fill = name)) +
  geom_boxplot() +
  scale_y_log10() +  # Use logarithmic scale for the y-axis
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(x = "Taxa", y = "log(Value)", fill = "Host Species") +
  scale_fill_manual(values = c("Betula_populifolia" = "#ecb21e", "Populus_tremuloides" = "#812e91"))
```


```{r}
set.seed(1985)

ggplot(ex_l, aes(x = taxa, y = value, fill = as.character(name), color = as.character(name))) +
  geom_boxplot() +
  facet_wrap(~taxa, scales = "free_x") +
  scale_custom_two +
  labs(y = expression("Abundance"),
       color = "Host Species") +
  guides(fill = "none") +  # Hide the fill legend
  theme_minimal()
```

```{r, warning=FALSE}
ggplot(ex_l, aes(x = taxa, y = value, fill = as.character(name), color = as.character(name))) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(~taxa, scales = "free_x") +
  scale_custom_two +
  labs(y = expression("log(Abundance)"),
       color = "Host Species") +
  guides(fill = "none") +  # Hide the fill legend
  theme_minimal()
```

```{r, warning=FALSE}
ex2 <- stackedBarPlots[[1]]$d # Choose level of taxono
ex_l2 <- tidyr::pivot_longer(ex2, cols = c("Betula_populifolia", "Populus_tremuloides"))

ggplot(ex_l2, aes(x = taxa, y = value, fill = as.character(name), color = as.character(name))) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(~taxa, scales = "free_x") +
  scale_custom_two +
  labs(y = expression("log(Abundance)"),
       color = "Host Species") +
  guides(fill = "none") +  # Hide the fill legend
  theme_minimal()
```

```{r}
# FIRST 25 Genera:

# Filter the data to include only the first 25 unique taxa
filtered_data <- ex_l2 %>%
 distinct(taxa) %>%
 slice_head(n = 25) %>%
 semi_join(ex_l2, ., by = "taxa")

# Now, plot using the filtered data
ggplot(filtered_data, aes(x = taxa, y = value, color = as.character(name))) +
 geom_boxplot() +
 scale_y_log10() +
 facet_wrap(~taxa, scales = "free_x") +
 labs(y = expression("log(Abundance)"),
       color = "Host Species") +
 guides(fill = "none") + # Hide the fill legend
 theme_minimal()
```


```{r}
## TOP 25 IN ABUNDANCE!!!***

# Define the taxa you're interested in
interested_taxa <- c("Not Assigned", "Endobacter", "Staphylococcus", "1174-901-12", "Quadrisphaera", 
                     "P3OB-42", "Rubellimicrobium", "Methylobacterium-Methylorubrum", "Actinomycetospora", 
                     "Ensifer", "Bradyrhizobium", "Curtobacterium", "Streptococcus", "Massilia", 
                     "Hymenobacter", "Micrococcus", "Erwinia", "Klenkia", "Robbsia", "Amnibacterium", 
                     "Roseomonas", "Ellin6055", "Corynebacterium", "Spirosoma", "Haemophilus")

# Filter ex_l2 to include only the interested taxa
filtered_data_raw_abund <- ex_l2 %>%
 filter(taxa %in% interested_taxa)

# Now, plot using the filtered data
raw_abund_genus_plot <- ggplot(filtered_data_raw_abund, aes(x = taxa, y = value, color = as.character(name))) +
 geom_boxplot() +
 scale_y_log10() +
 facet_wrap(~taxa, scales = "free_x") +
 labs(y = expression("log(Abundance)"),
       color = "Host Species") +
 guides(fill = "none") + # Hide the fill legend
 theme_minimal() 
#+
# theme(axis.text.x = element_text(angle = 5, hjust = 0.5))

raw_abund_genus_plot
```

```{r}
# Save the plot as a PNG file (you can change the file extension and parameters accordingly)
ggsave("raw_abund_genus_plot.jpg", plot = raw_abund_genus_plot, width = 12, height = 8, units = "in")
```


```{r}
# Filter ex_l2 to include only the interested taxa
filtered_data_rel_abund <- ex_l2 %>%
  filter(taxa %in% interested_taxa)

# Calculate relative abundance by taxa
relative_data <- filtered_data %>%
  group_by(taxa) %>%
  mutate(rel_abundance = value / sum(value))

# Now, plot using the filtered and calculated relative abundance data
rel_abund_genus_plot <- ggplot(relative_data, aes(x = taxa, y = rel_abundance, color = as.character(name))) +
  geom_boxplot() +
  scale_y_continuous() +  # Adjust y-axis to percentages
  facet_wrap(~taxa, scales = "free_x") +
  labs(y = "Relative Abundance", color = "Host Species") +
  guides(fill = "none") + # Hide the fill legend
  theme_minimal()

rel_abund_genus_plot
```

```{r}
# Save the plot as a PNG file (you can change the file extension and parameters accordingly)
ggsave("rel_abund_genus_plot.jpg", plot = rel_abund_genus_plot, width = 12, height = 8, units = "in")
```


```{r}
# Assuming 'filtered_data' is your data frame with taxa, value, and name

# Perform pairwise t-tests for each taxa across host species
pairwise_comparisons <- pairwise.t.test(filtered_data$value, filtered_data$taxa, 
                                       p.adjust.method = "BH")

# View the results
print(pairwise_comparisons)
```




################################################################################
## ASSESSING SIGNIFICANT TAXA AND ASVs:
################################################################################


## Phyloseq Statistics???


Here, I use the `phyloseq` object I made earlier, even though I generally did not use this package. My data structure didn't really feed into the `phyloseq` functions well, so I had to do some tweaks to the data structures to make the object. Hopefully, this has been done correctly...

I did this in order to perform Differential Taxa Abundance Analysis using `DESeq2`. 
  

################################################################################
## Differential Abundances of ASVs for Species (using `DESeq2`):
################################################################################

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("DESeq2")

```{r, message=FALSE, warning=FALSE}
library(DESeq2)
library(phyloseq)
```

```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------
#Extract the count data (otu_table) and sample metadata (sample_data) from the phyloseq object.

# Extract count data
otu_counts_LMM <- otu_table(ps_phen_asv_LMM)

# Extract sample metadata
sample_metadata_LMM <- sample_data(ps_phen_asv_LMM)

#DESeq2 requires count data to be in a specific format. Convert the count data into a matrix, and create a DESeq2 DDS object.

# Convert count data to matrix
otu_counts_matrix_LMM <- as.matrix(otu_counts_LMM)

#check that samples in metadata match those in the community data file 
(row.names(asv_scaled_noPlants_Phenology_stats_LMM)==row.names(otu_counts_LMM))

# Step 1: Transpose the otu_counts_matrix
transposed_otu_counts_matrix_LMM <- t(otu_counts_matrix_LMM)

#Also
ncol(transposed_otu_counts_matrix_LMM) == nrow(asv_scaled_noPlants_Phenology_stats_LMM)

# Step 2: Add a pseudocount: You can add a small pseudocount to all counts to avoid zero counts before creating the DESeq2 object
transposed_otu_counts_matrix_LMM <- transposed_otu_counts_matrix_LMM + 1

#Having issues with knitting, so use the `globalenv()` Function:** In the R code chunk where you define `transposed_otu_counts_matrix`, you can explicitly set the environment to the global environment using `assign()` and `globalenv()`:
assign("transposed_otu_counts_matrix_LMM", transposed_otu_counts_matrix_LMM, envir = globalenv())

# Step 3: Create a new phyloseq object using the transposed count matrix
ps_phen_asv_transposed_LMM <- phyloseq(otu_table(transposed_otu_counts_matrix_LMM, taxa_are_rows = TRUE),
                                  sample_data(sample_metadata_LMM),
                                  tax_table(taxa_rdp))

# Step 4: Convert the phyloseq object to a DESeqDataSet
dds_LMM <- phyloseq_to_deseq2(ps_phen_asv_transposed_LMM, ~ Species + GDD_5C + Species:GDD_5C)
dds_gdd <- phyloseq_to_deseq2(ps_phen_asv_transposed_LMM, ~ Species)

# Now, subset each `GDD_5C`:

dds_437 <- dds_gdd[, dds_gdd$GDD_5C %in% c(437)]
dds_605 <- dds_gdd[, dds_gdd$GDD_5C %in% c(605)]
dds_1087 <- dds_gdd[, dds_gdd$GDD_5C %in% c(1087)]
dds_1606 <- dds_gdd[, dds_gdd$GDD_5C %in% c(1606)]
dds_1992 <- dds_gdd[, dds_gdd$GDD_5C %in% c(1992)]
dds_2140 <- dds_gdd[, dds_gdd$GDD_5C %in% c(2140)]
dds_2219 <- dds_gdd[, dds_gdd$GDD_5C %in% c(2219)]
```

```{r}
#Now, you can use DESeq2 to perform differential abundance analysis. This will help identify ASVs and taxa associated with tree species and Growing-Degree-Days-5C.

# Perform DESeq2 analysis
dds_LMM <- DESeq(dds_LMM)

#Not appropriate to do, b/c overall DESeq shows both interspecific and intraspecific variation through sign & magnitude of Log2Fold Change.
# dds_Betula <- DESeq(dds_Betula)
# dds_Populus <- DESeq(dds_Populus)

dds_437 <- DESeq(dds_437)
dds_605 <- DESeq(dds_605)
dds_1087 <- DESeq(dds_1087)
dds_1606 <- DESeq(dds_1606)
dds_1992 <- DESeq(dds_1992)
dds_2140 <- DESeq(dds_2140)
dds_2219 <- DESeq(dds_2219)
```


```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------

# Get differential abundance results for tree species
results_species_diff_abund_LMM <- results(dds_LMM, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison

#significant_asvs_species_LMM <- subset(results_species_diff_abund_LMM, padj < 0.1)
significant_asvs_species_LMM <- subset(results_species_diff_abund_LMM)

head(significant_asvs_species_LMM)
```


```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------
#ASV Heatmap:

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM <- rownames(significant_asvs_species_LMM)
top_asv_counts_LMM <- counts(dds_LMM)[top_asv_names_LMM, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))
```


```{r}
# Save the heatmap as a PDF file
pdf("diffabund_heatmap_output.pdf")

# Your heatmap code again (to generate and save it in the PDF)
heatmap(as.matrix(top_asv_counts_LMM), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

# Close the PDF file
dev.off()
```


```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------
#----------------------------------------------------------
#Top ASVs Table for Species:
#----------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM <- significant_asvs_species_LMM[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM), "Genus"]

# Print the table
print(top_asv_table_spp_LMM)

head(top_asv_table_spp_LMM)
```


```{r, message=FALSE, warning=FALSE}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------

#NOTE: Shows most abundant ASVs OVERALL!! Not b/w tree species!

# Assuming you have a results table from DESeq2 named 'results_table'
# Select the columns you want in the table
top_asv_table_spp_LMM <-top_asv_table_spp_LMM[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Get the rownames of the top ASVs
top_asv_names_LMM <- rownames(top_asv_table_spp_LMM)

# Retrieve the taxonomic information for the top ASVs from 'tax_table'
top_asv_tax_LMM <- tax_table(ps_phen_asv_LMM)[top_asv_names_LMM, "Genus"]

# Add the taxonomic information to the table
top_asv_table_spp_LMM$Genus <- top_asv_tax_LMM

subset_top_asv_data_LMM <- top_asv_table_spp_LMM[1:10, ]

# Get the rownames of the top ASVs
top_asv_names_LMM <- rownames(top_asv_table_spp_LMM)

# Add the ASV information to the table as the first column
top_asv_table_spp_LMM <- cbind(ASV = top_asv_names_LMM, top_asv_table_spp_LMM)

# Now, top_asv_table_spp_LMM will have an "ASV" column

# Load the required libraries
library(knitr)
library(kableExtra)

# Convert the data frame to a kable object and format the table with custom styling
kable_table_LMM <- kable(subset_top_asv_data_LMM, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE) %>%
  row_spec(1, background = "lightgray") %>%
  row_spec(seq(2, nrow(subset_top_asv_data_LMM), by = 2), background = "whitesmoke") %>%
  row_spec(seq(3, nrow(subset_top_asv_data_LMM), by = 2), background = "white")

# Display only the first 10 rows in your RMarkdown document
kable_table_LMM
```

```{r}
# Export the table to a CSV file
write.csv(top_asv_table_spp_LMM, file = "top_asv_table_LMM.csv", row.names = FALSE)

# Export the table to a tab-separated TXT file
write.table(top_asv_table_spp_LMM, file = "top_asv_table_LMM.txt", sep = "\t", row.names = FALSE)
```


```{r, message=FALSE, warning=FALSE}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)

significant_results_spp_LMM <- subset(results_species_diff_abund_LMM, padj < 0.05)
#significant_results_spp_LMM <- subset(results_species_diff_abund_LMM)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM <- rownames(significant_results_spp_LMM)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM <- cbind(significant_asv_tax_spp_LMM, significant_results_spp_LMM)

# Select columns of interest for the final table
final_asv_table_spp_LMM <- significant_results_table_spp_LMM[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM <- final_asv_table_spp_LMM[1:10, ]

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM <- rownames(significant_results_spp_LMM)

# Add the ASV information to the table as the first column
final_asv_table_spp_LMM <- cbind(ASV = significant_asv_names_spp_LMM, final_asv_table_spp_LMM)

# Display the final table
kable(subset_final_asv_table_LMM, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)
```

```{r}
# Export the table to a CSV file
write.csv(final_asv_table_spp_LMM, file = "final_asv_table_LMM.csv", row.names = FALSE)

# Export the table to a tab-separated TXT file
write.table(final_asv_table_spp_LMM, file = "final_asv_table_LMM.txt", sep = "\t", row.names = FALSE)
```


################################################################################
## DESeq2: Differences b/w Betula & Populus
################################################################################

```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------

#To see differences b/w Populus and Betula

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM <- results_species_diff_abund_LMM[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM$ASV <- rownames(results_species_diff_abund_LMM)

# Merge with taxonomic information
results_betula_vs_populus_LMM <- cbind(results_betula_vs_populus_LMM, tax_table(ps_phen_asv_LMM)[rownames(results_species_diff_abund_LMM), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM <- results_betula_vs_populus_LMM[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM <- final_table_betula_vs_populus_LMM[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)
```

```{r}
# Export the table to a CSV file
write.csv(final_table_betula_vs_populus_LMM, file = "final_table_betula_vs_populus_LMM.csv", row.names = FALSE)

# Export the table to a tab-separated TXT file
write.table(final_table_betula_vs_populus_LMM, file = "final_table_betula_vs_populus_LMM.txt", sep = "\t", row.names = FALSE)
```


Interpreting the results of the log2 fold change (LFC) column is crucial in understanding the differences in abundance between "Betula_populifolia" and "Populus_tremuloides." The log2 fold change represents the magnitude of the change in abundance for each ASV between the two groups. Here's how to interpret it:

1. **Positive Log2 Fold Change:** A positive LFC indicates that the ASV is more abundant in "Betula_populifolia" compared to "Populus_tremuloides." The higher the positive LFC, the more significant the difference in abundance.

2. **Negative Log2 Fold Change:** A negative LFC indicates that the ASV is more abundant in "Populus_tremuloides" compared to "Betula_populifolia." The lower the negative LFC, the more significant the difference in abundance.

LFC = 0: An LFC of 0 means that there is no difference in abundance between the two groups.

Magnitude of LFC: The magnitude of the LFC is essential in determining the strength of the difference. Larger absolute values (closer to |LFC| = infinity) indicate more substantial changes in abundance.

NOTE: the significance of the LFC should be interpreted in the context of the padj (adjusted p-value) column. The padj represents the statistical significance of the LFC, and a padj value less than the chosen significance level (commonly 0.05) suggests a significant difference in abundance between the two groups.

In summary, should focus on ASVs with a significant padj value and a log2 fold change that is substantially different from 0. Those with the most extreme positive or negative LFC values are the most differentially abundant between "Betula_populifolia" and "Populus_tremuloides" and may be of particular interest for further investigation.


```{r}
#-------------------------------------------------------
## FOR `asv_scaled_noPlants_Phenology_stats_LMM` 
## (i.e., `asv_scaled_noPlants_Phen_filt_LMM`)
#-------------------------------------------------------

# Bar Plot

# Filter significant results (you can adjust the threshold for significance as needed)

significant_results_spp_LMM <- subset(results_species_diff_abund_LMM, padj < 0.05)
#significant_results_spp_LMM <- subset(results_species_diff_abund_LMM)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM <- data.frame(
  ASV = rownames(significant_results_spp_LMM),
  Log2FoldChange = significant_results_spp_LMM$log2FoldChange
)

# Sort the data frame by log2 fold change in descending order
data_for_barplot_LMM <- data_for_barplot_LMM[order(-data_for_barplot_LMM$Log2FoldChange), ]

# Create the bar plot
diff_abund_barplot <- ggplot(data_for_barplot_LMM, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Log2 Fold Change Between Betula_populifolia and Populus_tremuloides")

diff_abund_barplot
```

```{r}
# Save the plot as a PNG file (you can change the file extension and parameters accordingly)
ggsave("diff_abund_barplot.pdf", plot = diff_abund_barplot, width = 12, height = 8, units = "in")
```



################################################################################
## Differential Abundance of ASVs in GDDs
################################################################################

## Individual GDDs:

```{r}
#-------------------------------------------------------------------------------
## GDD 437
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_437 <- results(dds_437, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_437 <- subset(results_diff_abund_LMM_437, padj < 0.05)
significant_asvs_LMM_437 <- subset(results_diff_abund_LMM_437)

head(significant_asvs_LMM_437)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_437 <- rownames(significant_asvs_LMM_437)
top_asv_counts_LMM_437 <- counts(dds_437)[top_asv_names_LMM_437, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_437), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_437 <- significant_asvs_LMM_437[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_437$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_437), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_437)

head(top_asv_table_spp_LMM_437)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_437 <- subset(results_diff_abund_LMM_437, padj < 0.05)
significant_results_spp_LMM_437 <- subset(results_diff_abund_LMM_437)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_437 <- rownames(significant_results_spp_LMM_437)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_437 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_437, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_437 <- cbind(significant_asv_tax_spp_LMM_437, significant_results_spp_LMM_437)

# Select columns of interest for the final table
final_asv_table_spp_LMM_437 <- significant_results_table_spp_LMM_437[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_437) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_437 <- final_asv_table_spp_LMM_437[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_437, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_437 <- results_diff_abund_LMM_437[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_437$ASV <- rownames(results_diff_abund_LMM_437)

# Merge with taxonomic information
results_betula_vs_populus_LMM_437 <- cbind(results_betula_vs_populus_LMM_437, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_437), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_437 <- results_betula_vs_populus_LMM_437[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_437) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_437 <- final_table_betula_vs_populus_LMM_437[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_437, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_437 <- subset(results_diff_abund_LMM_437, padj < 0.05)
#significant_results_spp_LMM_437 <- subset(results_diff_abund_LMM_437)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_437 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_437),
  Log2FoldChange = significant_results_spp_LMM_437$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_437$AbsLog2FoldChange <- abs(data_for_barplot_LMM_437$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_437 <- data_for_barplot_LMM_437[order(-data_for_barplot_LMM_437$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_437 <- data_for_barplot_LMM_437[1:25, ]

data_for_barplot_LMM_437 <- na.omit(data_for_barplot_LMM_437)

# Create the bar plot
deseq_plot437 <- ggplot(data_for_barplot_LMM_437, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 437")))

deseq_plot437

ggsave("deseq_plot437.png", deseq_plot437, width=12, height=8)
```



```{r}
#-------------------------------------------------------------------------------
## GDD 605
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_605 <- results(dds_605, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_605 <- subset(results_diff_abund_LMM_605, padj < 0.05)
significant_asvs_LMM_605 <- subset(results_diff_abund_LMM_605)

head(significant_asvs_LMM_605)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_605 <- rownames(significant_asvs_LMM_605)
top_asv_counts_LMM_605 <- counts(dds_437)[top_asv_names_LMM_605, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_605), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_605 <- significant_asvs_LMM_605[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_605$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_605), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_605)

head(top_asv_table_spp_LMM_605)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_605 <- subset(results_diff_abund_LMM_605, padj < 0.05)
significant_results_spp_LMM_605 <- subset(results_diff_abund_LMM_605)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_605 <- rownames(significant_results_spp_LMM_605)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_605 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_605, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_605 <- cbind(significant_asv_tax_spp_LMM_605, significant_results_spp_LMM_605)

# Select columns of interest for the final table
final_asv_table_spp_LMM_605 <- significant_results_table_spp_LMM_605[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_605) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_605 <- final_asv_table_spp_LMM_605[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_605, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_605 <- results_diff_abund_LMM_605[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_605$ASV <- rownames(results_diff_abund_LMM_605)

# Merge with taxonomic information
results_betula_vs_populus_LMM_605 <- cbind(results_betula_vs_populus_LMM_605, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_605), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_605 <- results_betula_vs_populus_LMM_605[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_605) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_605 <- final_table_betula_vs_populus_LMM_605[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_605, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_605 <- subset(results_diff_abund_LMM_605, padj < 0.05)
#significant_results_spp_LMM_605 <- subset(results_diff_abund_LMM_605)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_605 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_605),
  Log2FoldChange = significant_results_spp_LMM_605$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_605$AbsLog2FoldChange <- abs(data_for_barplot_LMM_605$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_605 <- data_for_barplot_LMM_605[order(-data_for_barplot_LMM_605$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_605 <- data_for_barplot_LMM_605[1:25, ]

data_for_barplot_LMM_605 <- na.omit(data_for_barplot_LMM_605)

# Create the bar plot
deseq_plot605 <- ggplot(data_for_barplot_LMM_605, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 605")))

deseq_plot605

ggsave("deseq_plot605.png", deseq_plot605, width=12, height=8)
```


```{r}
#-------------------------------------------------------------------------------
## GDD 1087
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_1087 <- results(dds_1087, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_1087 <- subset(results_diff_abund_LMM_1087, padj < 0.05)
significant_asvs_LMM_1087 <- subset(results_diff_abund_LMM_1087)

head(significant_asvs_LMM_1087)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_1087 <- rownames(significant_asvs_LMM_1087)
top_asv_counts_LMM_1087 <- counts(dds_1087)[top_asv_names_LMM_1087, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_1087), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_1087 <- significant_asvs_LMM_1087[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_1087$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_1087), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_1087)

head(top_asv_table_spp_LMM_1087)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_1087 <- subset(results_diff_abund_LMM_1087, padj < 0.05)
significant_results_spp_LMM_1087 <- subset(results_diff_abund_LMM_1087)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_1087 <- rownames(significant_results_spp_LMM_1087)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_1087 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_1087, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_1087 <- cbind(significant_asv_tax_spp_LMM_1087, significant_results_spp_LMM_1087)

# Select columns of interest for the final table
final_asv_table_spp_LMM_1087 <- significant_results_table_spp_LMM_1087[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_1087) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_1087 <- final_asv_table_spp_LMM_1087[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_1087, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_1087 <- results_diff_abund_LMM_1087[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_1087$ASV <- rownames(results_diff_abund_LMM_1087)

# Merge with taxonomic information
results_betula_vs_populus_LMM_1087 <- cbind(results_betula_vs_populus_LMM_1087, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_1087), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_1087 <- results_betula_vs_populus_LMM_1087[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_1087) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_1087 <- final_table_betula_vs_populus_LMM_1087[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_1087, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_1087 <- subset(results_diff_abund_LMM_1087, padj < 0.05)
#significant_results_spp_LMM_1087 <- subset(results_diff_abund_LMM_1087)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_1087 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_1087),
  Log2FoldChange = significant_results_spp_LMM_1087$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_1087$AbsLog2FoldChange <- abs(data_for_barplot_LMM_1087$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_1087 <- data_for_barplot_LMM_1087[order(-data_for_barplot_LMM_1087$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_1087 <- data_for_barplot_LMM_1087[1:25, ]

data_for_barplot_LMM_1087 <- na.omit(data_for_barplot_LMM_1087)

# Create the bar plot
deseq_plot1087 <- ggplot(data_for_barplot_LMM_1087, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 1087")))

deseq_plot1087

ggsave("deseq_plot1087.png", deseq_plot1087, width=12, height=8)
```



```{r}
#-------------------------------------------------------------------------------
## GDD 1606
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_1606 <- results(dds_1606, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_1606 <- subset(results_diff_abund_LMM_1606, padj < 0.05)
significant_asvs_LMM_1606 <- subset(results_diff_abund_LMM_1606)

head(significant_asvs_LMM_1606)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_1606 <- rownames(significant_asvs_LMM_1606)
top_asv_counts_LMM_1606 <- counts(dds_1606)[top_asv_names_LMM_1606, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_1606), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_1606 <- significant_asvs_LMM_1606[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_1606$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_1606), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_1606)

head(top_asv_table_spp_LMM_1606)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_1606 <- subset(results_diff_abund_LMM_1606, padj < 0.05)
significant_results_spp_LMM_1606 <- subset(results_diff_abund_LMM_1606)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_1606 <- rownames(significant_results_spp_LMM_1606)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_1606 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_1606, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_1606 <- cbind(significant_asv_tax_spp_LMM_1606, significant_results_spp_LMM_1606)

# Select columns of interest for the final table
final_asv_table_spp_LMM_1606 <- significant_results_table_spp_LMM_1606[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_1606) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_1606 <- final_asv_table_spp_LMM_1606[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_1606, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_1606 <- results_diff_abund_LMM_1606[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_1606$ASV <- rownames(results_diff_abund_LMM_1606)

# Merge with taxonomic information
results_betula_vs_populus_LMM_1606 <- cbind(results_betula_vs_populus_LMM_1606, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_1606), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_1606 <- results_betula_vs_populus_LMM_1606[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_1606) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_1606 <- final_table_betula_vs_populus_LMM_1606[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_1606, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_1606 <- subset(results_diff_abund_LMM_1606, padj < 0.05)
#significant_results_spp_LMM_1606 <- subset(results_diff_abund_LMM_1606)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_1606 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_1606),
  Log2FoldChange = significant_results_spp_LMM_1606$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_1606$AbsLog2FoldChange <- abs(data_for_barplot_LMM_1606$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_1606 <- data_for_barplot_LMM_1606[order(-data_for_barplot_LMM_1606$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_1606 <- data_for_barplot_LMM_1606[1:25, ]

data_for_barplot_LMM_1606 <- na.omit(data_for_barplot_LMM_1606)

# Create the bar plot
deseq_plot1606 <- ggplot(data_for_barplot_LMM_1606, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 1606")))

deseq_plot1606

ggsave("deseq_plot1606.png", deseq_plot1606, width=12, height=8)
```


```{r}
#-------------------------------------------------------------------------------
## GDD 1992
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_1992 <- results(dds_1992, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_1992 <- subset(results_diff_abund_LMM_1992, padj < 0.05)
significant_asvs_LMM_1992 <- subset(results_diff_abund_LMM_1992)

head(significant_asvs_LMM_1992)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_1992 <- rownames(significant_asvs_LMM_1992)
top_asv_counts_LMM_1992 <- counts(dds_1992)[top_asv_names_LMM_1992, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_1992), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_1992 <- significant_asvs_LMM_1992[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_1992$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_1992), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_1992)

head(top_asv_table_spp_LMM_1992)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_1992 <- subset(results_diff_abund_LMM_1992, padj < 0.05)
significant_results_spp_LMM_1992 <- subset(results_diff_abund_LMM_1992)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_1992 <- rownames(significant_results_spp_LMM_1992)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_1992 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_1992, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_1992 <- cbind(significant_asv_tax_spp_LMM_1992, significant_results_spp_LMM_1992)

# Select columns of interest for the final table
final_asv_table_spp_LMM_1992 <- significant_results_table_spp_LMM_1992[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_1992) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_1992 <- final_asv_table_spp_LMM_1992[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_1992, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_1992 <- results_diff_abund_LMM_1992[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_1992$ASV <- rownames(results_diff_abund_LMM_1992)

# Merge with taxonomic information
results_betula_vs_populus_LMM_1992 <- cbind(results_betula_vs_populus_LMM_1992, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_1992), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_1992 <- results_betula_vs_populus_LMM_1992[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_1992) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_1992 <- final_table_betula_vs_populus_LMM_1992[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_1992, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_1992 <- subset(results_diff_abund_LMM_1992, padj < 0.05)
#significant_results_spp_LMM_1992 <- subset(results_diff_abund_LMM_1992)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_1992 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_1992),
  Log2FoldChange = significant_results_spp_LMM_1992$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_1992$AbsLog2FoldChange <- abs(data_for_barplot_LMM_1992$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_1992 <- data_for_barplot_LMM_1992[order(-data_for_barplot_LMM_1992$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_1992 <- data_for_barplot_LMM_1992[1:25, ]

data_for_barplot_LMM_1992 <- na.omit(data_for_barplot_LMM_1992)

# Create the bar plot
deseq_plot1992 <- ggplot(data_for_barplot_LMM_1992, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 1992")))

deseq_plot1992

ggsave("deseq_plot1992.png", deseq_plot1992, width=12, height=8)
```


```{r}
#-------------------------------------------------------------------------------
## GDD 2140
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_2140 <- results(dds_2140, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_2140 <- subset(results_diff_abund_LMM_2140, padj < 0.05)
significant_asvs_LMM_2140 <- subset(results_diff_abund_LMM_2140)

head(significant_asvs_LMM_2140)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_2140 <- rownames(significant_asvs_LMM_2140)
top_asv_counts_LMM_2140 <- counts(dds_2140)[top_asv_names_LMM_2140, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_2140), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_2140 <- significant_asvs_LMM_2140[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_2140$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_2140), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_2140)

head(top_asv_table_spp_LMM_2140)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_2140 <- subset(results_diff_abund_LMM_2140, padj < 0.05)
significant_results_spp_LMM_2140 <- subset(results_diff_abund_LMM_2140)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_2140 <- rownames(significant_results_spp_LMM_2140)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_2140 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_2140, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_2140 <- cbind(significant_asv_tax_spp_LMM_2140, significant_results_spp_LMM_2140)

# Select columns of interest for the final table
final_asv_table_spp_LMM_2140 <- significant_results_table_spp_LMM_2140[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_2140) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_2140 <- final_asv_table_spp_LMM_2140[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_2140, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_2140 <- results_diff_abund_LMM_2140[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_2140$ASV <- rownames(results_diff_abund_LMM_2140)

# Merge with taxonomic information
results_betula_vs_populus_LMM_2140 <- cbind(results_betula_vs_populus_LMM_2140, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_2140), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_2140 <- results_betula_vs_populus_LMM_2140[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_2140) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_2140 <- final_table_betula_vs_populus_LMM_2140[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_2140, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_2140 <- subset(results_diff_abund_LMM_2140, padj < 0.05)
#significant_results_spp_LMM_2140 <- subset(results_diff_abund_LMM_2140)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_2140 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_2140),
  Log2FoldChange = significant_results_spp_LMM_2140$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_2140$AbsLog2FoldChange <- abs(data_for_barplot_LMM_2140$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_2140 <- data_for_barplot_LMM_2140[order(-data_for_barplot_LMM_2140$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_2140 <- data_for_barplot_LMM_2140[1:25, ]

data_for_barplot_LMM_2140 <- na.omit(data_for_barplot_LMM_2140)

# Create the bar plot
deseq_plot2140 <- ggplot(data_for_barplot_LMM_2140, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 2140")))

deseq_plot2140

ggsave("deseq_plot2140.png", deseq_plot2140, width=12, height=8)
```


```{r}
#-------------------------------------------------------------------------------
## GDD 2219
#-------------------------------------------------------------------------------

# Get differential abundance results for tree species
results_diff_abund_LMM_2219 <- results(dds_2219, contrast=c("Species", "Betula_populifolia", "Populus_tremuloides"))

# Filter significant ASVs for species comparison
#significant_asvs_LMM_2219 <- subset(results_diff_abund_LMM_2219, padj < 0.05)
significant_asvs_LMM_2219 <- subset(results_diff_abund_LMM_2219)

head(significant_asvs_LMM_2219)

#-------------------------------------------------------------------------------
#ASV Heatmap:
#-------------------------------------------------------------------------------

# Assuming 'dds' is your DESeq2 object and 'top_asvs' is the data frame containing top ASVs
top_asv_names_LMM_2219 <- rownames(significant_asvs_LMM_2219)
top_asv_counts_LMM_2219 <- counts(dds_2219)[top_asv_names_LMM_2219, ]

# Create the heatmap
heatmap(as.matrix(top_asv_counts_LMM_2219), scale = "row", Rowv = FALSE, Colv = FALSE, col = viridis::viridis(100))

#-------------------------------------------------------------------------------
# Top ASVs for Species:
#-------------------------------------------------------------------------------

# Select the columns you want in the table
top_asv_table_spp_LMM_2219 <- significant_asvs_LMM_2219[, c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj")]

# Optionally, you can add the taxonomic information if available
# Assuming you have a taxonomic table named 'tax_table' with a column 'Genus'
top_asv_table_spp_LMM_2219$Genus <- taxa_rdp[rownames(top_asv_table_spp_LMM_2219), "Genus"]

# Print the table
print(top_asv_table_spp_LMM_2219)

head(top_asv_table_spp_LMM_2219)

#-------------------------------------------------------------------------------
# Making Kable Table
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
#significant_results_spp_LMM_2219 <- subset(results_diff_abund_LMM_2219, padj < 0.05)
significant_results_spp_LMM_2219 <- subset(results_diff_abund_LMM_2219)

# Get ASV names of differentially abundant ASVs
significant_asv_names_spp_LMM_2219 <- rownames(significant_results_spp_LMM_2219)

# Get the taxonomic information for the significant ASVs
significant_asv_tax_spp_LMM_2219 <- tax_table(ps_phen_asv_LMM)[significant_asv_names_spp_LMM_2219, ]

# Merge the results with taxonomic information
significant_results_table_spp_LMM_2219 <- cbind(significant_asv_tax_spp_LMM_2219, significant_results_spp_LMM_2219)

# Select columns of interest for the final table
final_asv_table_spp_LMM_2219 <- significant_results_table_spp_LMM_2219[, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange", "pvalue", "padj")]

# Rename the columns for better presentation
colnames(final_asv_table_spp_LMM_2219) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change", "P-value", "Adjusted P-value")

subset_final_asv_table_LMM_2219 <- final_asv_table_spp_LMM_2219[1:10, ]

# Display the final table
kable(subset_final_asv_table_LMM_2219, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
#To see differences b/w Populus and Betula
#-------------------------------------------------------------------------------

# Filter results for the "Betula_populifolia vs Populus_tremuloides" comparison
results_betula_vs_populus_LMM_2219 <- results_diff_abund_LMM_2219[, "log2FoldChange", drop = FALSE]

# Add ASV names to the results
results_betula_vs_populus_LMM_2219$ASV <- rownames(results_diff_abund_LMM_2219)

# Merge with taxonomic information
results_betula_vs_populus_LMM_2219 <- cbind(results_betula_vs_populus_LMM_2219, tax_table(ps_phen_asv_LMM)[rownames(results_diff_abund_LMM_2219), ])

# Select the columns of interest for the final table
final_table_betula_vs_populus_LMM_2219 <- results_betula_vs_populus_LMM_2219[, c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "log2FoldChange")]

# Rename the columns for better presentation
colnames(final_table_betula_vs_populus_LMM_2219) <- c("ASV", "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Log2 Fold Change")

subset_bet_vs_pop_LMM_2219 <- final_table_betula_vs_populus_LMM_2219[1:10, ]

# Display the final table
library(knitr)
kable(subset_bet_vs_pop_LMM_2219, format = "html", align = "c") %>%
  kable_styling(bootstrap_options = "striped", full_width = TRUE)

#-------------------------------------------------------------------------------
# Bar Plot
#-------------------------------------------------------------------------------

# Filter significant results (you can adjust the threshold for significance as needed)
significant_results_spp_LMM_2219 <- subset(results_diff_abund_LMM_2219, padj < 0.05)
#significant_results_spp_LMM_2219 <- subset(results_diff_abund_LMM_2219)

# Create a data frame with ASV names and log2 fold change values
data_for_barplot_LMM_2219 <- data.frame(
  ASV = rownames(significant_results_spp_LMM_2219),
  Log2FoldChange = significant_results_spp_LMM_2219$log2FoldChange
)

# Add a new column for the absolute values of Log2FoldChange
data_for_barplot_LMM_2219$AbsLog2FoldChange <- abs(data_for_barplot_LMM_2219$Log2FoldChange)

# Sort the data frame by the absolute values of Log2FoldChange in descending order
data_for_barplot_LMM_2219 <- data_for_barplot_LMM_2219[order(-data_for_barplot_LMM_2219$AbsLog2FoldChange), ]

# Select the top 100 ASVs for the bar plot
data_for_barplot_LMM_2219 <- data_for_barplot_LMM_2219[1:25, ]

data_for_barplot_LMM_2219 <- na.omit(data_for_barplot_LMM_2219)

# Create the bar plot
deseq_plot2219 <- ggplot(data_for_barplot_LMM_2219, aes(x = ASV, y = Log2FoldChange)) +
  geom_bar(stat = "identity", fill = "lightblue", color = "black") +
  labs(x = "ASV", y = "Log2 Fold Change") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(expression(paste("Top 100 ASVs: Log2 Fold Change Between ", italic("Betula populifolia"), " and ", italic("Populus tremuloides"), " within Growing Degree Days 2219")))

deseq_plot2219

ggsave("deseq_plot2219.png", deseq_plot2219, width=12, height=8)
```


```{r}
library(gridExtra)
library(jpeg)

# Arrange the plots in a grid
deseq_plots_combined <- arrangeGrob(deseq_plot437, deseq_plot605, deseq_plot1087, deseq_plot1606, deseq_plot1992, deseq_plot2140, deseq_plot2219, ncol=3, nrow=3)

# Save the combined plot
ggsave("deseq_plots_combined.png", deseq_plots_combined, width=12, height=8)  # Adjust width and height as needed
```


################################################################################
## INTRASPECIFIC DESeq2 (WITHIN HOST SPECIES, BETULA & POPULUS, SEPARATE:
################################################################################

**NOTE:** I think we can see that in the overall DESeq2, no???


################################################################################


### INSTEAD OF MERGIND METADATA, ASVs, & TAXA INFO: Assign Taxa to ASVs in a new object that contains Metadata+Taxa only, no ASVs?


```{r}
# Define a function to rename ASV columns based on Genus assignments
rename_asv_columns_taxa <- function(data, tx_data, taxonomic_level) {
  # Get the ASV column names
  asv_columns <- colnames(data)[-(1730:1757)]  # Assuming the first two columns are metadata
  
  # Create a new data frame to store the renamed columns
  new_data <- data
  
  # Iterate through ASV columns and rename them based on Genus assignments
  for (asv_col in asv_columns) {
    # Get the ASV identifier
    asv_id <- asv_col
    
    # Get the Genus assignment from tx_data based on ASV identifier
    genus <- tx_data[asv_id, taxonomic_level]
    
    # Rename the column with Genus assignment
    colnames(new_data)[colnames(new_data) == asv_col] <- genus
  }
  
  return(new_data)
}

# Specify the taxonomic level you want to use for renaming (e.g., "Genus")
taxonomic_level1 <- "Genus"
taxonomic_level2 <- "Family"
taxonomic_level3 <- "Order"
taxonomic_level4 <- "Phylum"

# Create a new data frame with ASV columns renamed based on Genus assignments
taxa_scaled_noPlants_Phenology_genus <- rename_asv_columns_taxa(asv_scaled_noPlants_Phen_filt_LMM, tx, taxonomic_level1)
taxa_scaled_noPlants_Phenology_family <- rename_asv_columns_taxa(asv_scaled_noPlants_Phen_filt_LMM, tx, taxonomic_level2)
taxa_scaled_noPlants_Phenology_order <- rename_asv_columns_taxa(asv_scaled_noPlants_Phen_filt_LMM, tx, taxonomic_level3)
taxa_scaled_noPlants_Phenology_phyla <- rename_asv_columns_taxa(asv_scaled_noPlants_Phen_filt_LMM, tx, taxonomic_level4)

head(taxa_scaled_noPlants_Phenology_genus)
head(taxa_scaled_noPlants_Phenology_family)
head(taxa_scaled_noPlants_Phenology_order)
head(taxa_scaled_noPlants_Phenology_phyla)

write.csv(taxa_scaled_noPlants_Phenology_phyla, "taxa_scaled_phyla.csv")
```


################################################################################
### PHYLOSEQ BY ITUMELENG???
################################################################################


```{r}
library(phangorn)
library(Biostrings)
library(DECIPHER)

seqsdada<-colnames(seqtab.nochim)[as.numeric(substr(colnames(asv[,grepl("ASV",colnames(asv))]),4,nchar(colnames(asv[,grepl("ASV",colnames(asv))]))))]
names(seqsdada)<-seqsdada

#alignment <- AlignSeqs(DNAStringSet(seqsdada), anchor=NA,processors=6)
 # phang.align <- phyDat(as(alignment, "matrix"), type="DNA")
  #dm <- dist.ml(phang.align)
  #treeNJ <- NJ(dm)
  #fit = pml(treeNJ, data=phang.align)
  #fitGTR <- update(fit, k=4, inv=0.2)
  #startTime<-Sys.time()
  #fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
   #                   rearrangement = "stochastic", control = pml.control(trace = 0))
  #endTime<-Sys.time()
  #endTime-startTime
  #save(fitGTR,file="phangornTree.rdata")

asvMat<-as.matrix(asv[,grepl("ASV",colnames(asv))])
colnames(asvMat)<-seqsdada
ASV = otu_table(asvMat, taxa_are_rows = F)
taxa<-as.data.frame(taxa_rdp)
taxa<-taxa[rownames(taxa) %in% colnames(asv[ ,grepl("ASV",colnames(asv))]), ]
taxMat<-as.matrix(taxa)
rownames(taxMat)<-seqsdada
TAX = tax_table(taxMat)
META = sample_data(asv_scaled_noPlants_Phenology_filtered)
#TREE<-phy_tree(fitGTR$tree)
#physeq.unrooted = phyloseq(ASV, TAX, TREE)
#save(physeq.unrooted,file="physeqUnrooted")
#rooted.tree <- ape::root(TREE, outgroup=pick_new_outgroup(TREE), resolve.root=TRUE)
ps_phen2 = phyloseq(ASV, TAX, META)
```

################################################################################
##                        INTERSPECIFIC STATISTICS
################################################################################


```{r}
#Create new objects & convert `Species` to factor & `Growing-Degree-Days-5C` to numeric for ALL objects used in stats

asv_scaled_noPlants_Phen_filt_LMM <- as.data.frame(asv_scaled_noPlants_Phenology_filtered)

# Convert the factor to numeric without changing the values
asv_scaled_noPlants_Phen_filt_LMM$`Growing-Degree-Days-5C` <- as.numeric(as.character(asv_scaled_noPlants_Phen_filt_LMM$`Growing-Degree-Days-5C`))

# Convert to `Species` to factor
asv_scaled_noPlants_Phen_filt_LMM$Species <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Species)

# Convert to `Plant_ID` to factor
asv_scaled_noPlants_Phen_filt_LMM$Plant_ID <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Plant_ID)

# Convert to `Collection-Month` to factor
asv_scaled_noPlants_Phen_filt_LMM$`Collection-Month` <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$`Collection-Month`)

# Rename the 'Growing-Degree-Days-5C' variable to 'GDD5C'
colnames(asv_scaled_noPlants_Phen_filt_LMM)[colnames(asv_scaled_noPlants_Phen_filt_LMM) == 'Growing-Degree-Days-5C'] <- 'GDD_5C'
```

```{r}
## Subsetting GDDs!!!!!!!!!!!!!!!!!!!!!!!!

#1) Split data into each GDD & assess diffs at that ONE GDD, or
#2) Split data into transitions between GDDs (i.e., subset 437-605, 605-1087, 1087-1606, etc.), or
#3) Split data into Early-, Mid-, and Late-season (make categorical though)?

#OR:
# Do pairwise post-hoc on `Species` at each `GDD` value or in ranges like early-, mid-, late- (since `GDD` is numeric, can't do post-hocs) to see at which `GDD` the `Species` differ most (estimated marginal means (EMMs) will show expected diversity value, e.g. expected Shannon, etc.)
```


################################################################################
## ALPHA DIVERSITY
################################################################################


################################################################################
### 1. ASV Richness
################################################################################

```{r}
#-------------------------------------------------------------------------
# Homogeneity of Slopes faceted by 'Species'
#-------------------------------------------------------------------------

##NOTE: Homoegenity of slopes is just looking at the data but not the actual results, plus there are no error bars, so it's telling if there's potentially an interaction, but not definitely whether or not. Do NOT rely on this, especially b/c no error bars. Traditional ANCOVA moving away from this?

#-------------------------------------------------------------------------
# (a) x=`GDD_5C`
#-------------------------------------------------------------------------
#Untransformed: based on these plots is that the slopes are not homogenous between Betula and Populus, indicating that the relationship between Growing-Degree-Days-5C and specnumber varies significantly between the two species.
#If the slopes of the data within `Species` are unequal (they are), there is a potentially an interaction between `Species` and `GDD_5C`. 
#If there are differences in the intercepts (there are), there may be differences in the medians across the levels (`Species`). This type of test is very preliminary, and only looks at the data, not the statistical results.

#NOTE: Transformations do not really help at all. 

levels = c("Betula_populifolia", "Populus_tremuloides")
myplot_specnumber <- ggplot(data = asv_scaled_noPlants_Phen_filt_LMM, aes(x=GDD_5C,
y=specnumber))+facet_grid(.~Species)+geom_point()
myplot_specnumber <- myplot_specnumber+
 stat_smooth(method = lm, se=FALSE)+
 stat_smooth(se=FALSE, color="red") +
 labs(
 y = expression(~specnumber),
 x = expression(~GDD_5C))
myplot_specnumber
```



```{r}
library(ggplot2)

myplot_specnumber2 <- ggplot(data = asv_scaled_noPlants_Phen_filt_LMM, aes(x = GDD_5C, y = log(specnumber))) +
  facet_grid(. ~ Species) +
  geom_point() +
  stat_smooth(method = lm, se = FALSE) +
  stat_smooth(se = FALSE, color = "red") +
  labs(y = expression(~specnumber), x = expression(~GDD_5C)) +
  geom_text(
    aes(
      x = Inf, y = -Inf,
      label = paste("R-squared: ", round(summary(lm(log(specnumber) ~ GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM))$r.squared, 3))
    ),
    hjust = 1, vjust = 0, color = "blue", size = 3
  )

myplot_specnumber2
```



```{r, warning=FALSE}
#-------------------------------------------------------------------------
# Visualize data with a Scatterplot Matrix
#-------------------------------------------------------------------------

# To evaluate not only linearity, but also collinearity; r.e. lecture on Multiple Regression (lec. 16/17) slide 46

plot <- scatterplotMatrix(
  ~ specnumber + Species + GDD_5C,
  regLine = TRUE, smooth = TRUE, diagonal = TRUE,
  data = asv_scaled_noPlants_Phen_filt_LMM
)
```


```{r, warning=FALSE}
#-------------------------------------------------------------------------------
## Linear Mixed-Model (ASV Richness)
#-------------------------------------------------------------------------------

#install.packages("lmerTest")
#install.packages("lme4")
#install.packages("see")
library(lmerTest)
library(lme4)
library(see)

# Fit the linear mixed-effects model
lmm_model_specnumber1 <- lmer(specnumber ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber1)
```



```{r}
#-------------------------------------------------------------------------------
## LMM with sqrt-transformed `specnumber` (ASV richness)
#-------------------------------------------------------------------------------

# Fit the linear mixed-effects model
lmm_model_specnumber2 <- lmer(sqrt(specnumber) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber2)
```


```{r}
#-------------------------------------------------------------------------------
## LMM with log-transformed `specnumber` (ASV richness)
#-------------------------------------------------------------------------------

# Fit the linear mixed-effects model
lmm_model_specnumber3 <- lmer(log(specnumber) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber3)
```

```{r}
#-------------------------------------------------------------------------------
## LMM with log-transformed `specnumber` (ASV richness) AND `Collection-Month` as random var?
#-------------------------------------------------------------------------------

# Fit the linear mixed-effects model
lmm_model_specnumber3_plantid_month <- lmer(log(specnumber) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID) + (1 | `Collection-Month`), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber3_plantid_month)
```

```{r}
#-------------------------------------------------------------------------------
## LMM with log-transformed `specnumber` (ASV richness) AND `Collection-Month` as random var?
#-------------------------------------------------------------------------------

# Fit the linear mixed-effects model
lmm_model_specnumber3_month <- lmer(log(specnumber) ~ Species + GDD_5C + Species:GDD_5C +(1 | `Collection-Month`), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber3_month)
```


```{r}
#-------------------------------------------------------------------------------
## LMM with square-transformed `specnumber` (ASV richness)
#-------------------------------------------------------------------------------

# Fit the linear mixed-effects model
lmm_model_specnumber4 <- lmer(I(specnumber^2) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber4)
```



```{r}
#-------------------------------------------------------------------------------
## ANCOVA
#-------------------------------------------------------------------------------

# Perform ANCOVA
ancova_specnumber1 <- lm(specnumber ~ Species + GDD_5C + Species:GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM)

Anova(ancova_specnumber1, type=3)

summary(ancova_specnumber1)

#Adjusted R^2 = 0.07108 

#------------------------------------------------------------------------------

# Perform ANCOVA (log-transformed)
ancova_specnumber2 <- lm(log(specnumber) ~ Species + GDD_5C + Species:GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM)

Anova(ancova_specnumber2, type=3)

summary(ancova_specnumber2)

#Adjusted R^2 = 0.1285 
```



```{r}
#-------------------------------------------------------------------------
# Formal Test of Homoscedasticity:
#-------------------------------------------------------------------------

bptest(ancova_specnumber1) # p = 0.39; homoscedasticity is good
bptest(ancova_specnumber2) # p = 0.39; homoscedasticity is good

#-------------------------------------------------------------------------
# Formal Test of Linearity (RESET Test)
#-------------------------------------------------------------------------

resettest(ancova_specnumber1, type = "regressor", data = asv_scaled_noPlants_Phen_filt_LMM) # p = 0.74; Linearity is good
resettest(ancova_specnumber2, type = "regressor", data = asv_scaled_noPlants_Phen_filt_LMM) # p = 0.59; Linearity is good.

#--------------------------------------------------------------------------
# Formal Test of Serial Correlation 
#--------------------------------------------------------------------------

dwtest(ancova_specnumber1) # DW = 0.9941 -> may have autocorrelation
dwtest(ancova_specnumber2) # DW = 0.9969 -> may have autocorrelation

#-------------------------------------------------------------------------
## Variance Inflation Factors (VIFs)
#-------------------------------------------------------------------------

vif(ancova_specnumber1)
vif(ancova_specnumber2)

## In summary, multicollinearity exists in the model, particularly for the interaction term and the SpeciesPopulus_tremuloides predictor

#-------------------------------------------------------------------------
## AIC:
#-------------------------------------------------------------------------

AIC(ancova_specnumber1) #AIC = 679.3519
AIC(ancova_specnumber2) #AIC = 121.0137

## `ancova_specnumber2` has lowest AIC -> likely the better ANCOVA model (plus better R^2)

## NOTE: This block of code & associated analyses ONLY apply to ANCOVA, not the LMM. 
```



```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_specnumber1)) # p=5.141e-05 -> NOT Normal!
shapiro.test(residuals(lmm_model_specnumber2)) # p=0.006245 -> NOT Normal!
shapiro.test(residuals(lmm_model_specnumber3)) # p=0.1763 -> Normality is good!
shapiro.test(residuals(lmm_model_specnumber4)) # p=1.27e-08 -> NOT Normal!
shapiro.test(residuals(ancova_specnumber1))    # p=6.145e-05 -> NOT Normal
shapiro.test(residuals(ancova_specnumber2))    # p=0.7853 -> MOST Normal!
shapiro.test(residuals(lmm_model_specnumber3_plantid_month)) # p=0.1786 -> Normal!
shapiro.test(residuals(lmm_model_specnumber3_month)) # p=0.7729 -> Normal!
```


```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_specnumber1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_specnumber2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_specnumber3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_specnumber4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(ancova_specnumber1)
check_model(ancova_specnumber2)

## `lmm_model_specnumber2` and `lmm_model_specnumber3` look to have the best residuals diagnostics.
## BUT: `lmm_model_specnumber3` looks better + given everything else (AICs, BICs, normality, etc.)
```


```{r}
check_model(lmm_model_specnumber3_plantid_month, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_specnumber3_month, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```



```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model' with ANCOVA model:

anova(lmm_model_specnumber1, lmm_model_specnumber2, lmm_model_specnumber3, lmm_model_specnumber4, ancova_specnumber1, ancova_specnumber2, lmm_model_specnumber3_plantid_month, lmm_model_specnumber3_month)


# `lmm_model_specnumber3` has the lowest AIC and BIC, so it's likely the best model. It also has lowest deviance and highest logLik (all followed closely `by ancova_specnumber2`)
```


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_specnumber1 <- Anova(lmm_model_specnumber1)
anova_lmm_specnumber2 <- Anova(lmm_model_specnumber2)
anova_lmm_specnumber3 <- Anova(lmm_model_specnumber3)
anova_lmm_specnumber4 <- Anova(lmm_model_specnumber4)
anova_ancova_specnumber1 <- Anova(ancova_specnumber1)
anova_ancova_specnumber2 <- Anova(ancova_specnumber2)
anova_lmm_model_specnumber3_plantid_month <- Anova(lmm_model_specnumber3_plantid_month)
anova_lmm_model_specnumber3_month <- Anova(lmm_model_specnumber3_month)

summary(anova_lmm_specnumber1)
summary(anova_lmm_specnumber2)
summary(anova_lmm_specnumber3)
summary(anova_lmm_specnumber4)
summary(anova_ancova_specnumber1)
summary(anova_ancova_specnumber2)
summary(anova_lmm_model_specnumber3_plantid_month)
summary(anova_lmm_model_specnumber3_month)
```

```{r}
#-------------------------------------------------------------------------------
## CHOICE: LMM with log-transformed `specnumber` (ASV richness) !!!
#-------------------------------------------------------------------------------
# `lmm_model_specnumber3`
#-------------------------------------------------------------------------------

## ANALYSIS/JUSTIFICATION:

##1. Diagnostic statistics: `lmm_model_specnumber3` has slightly worse diagnostic statistics than `lmm_model_specnumber3_month`, particularly in terms of linearity, homogeneity of variance, and normality.
##2. Collinearity: `lmm_model_specnumber3` has better collinearity than `lmm_model_specnumber3_month`, with no collinearity problems between predictors.
## Model fit: `lmm_model_specnumber3` has slightly lower AIC and BIC values than `lmm_model_specnumber3_month`, and lowest overall, indicating a slightly better fit compared to `lmm_model_specnumber3_month`.
##3. Convergence: `lmm_model_specnumber3` does not have a convergence or singularity issue, unlike ``lmm_model_specnumber3`.

# While diagnostic statistics are important, the absence of collinearity issues and the ability to converge without singularity problems are also crucial considerations. Furthermore, the slightly better model fit of `lmm_model_specnumber3` suggests that it may provide a better balance between model complexity and goodness of fit.

# THIS IS WHY WE CHOOSE `lmm_model_specnumber3`

# Fit the linear mixed-effects model
lmm_model_specnumber3 <- lmer(log(specnumber) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_specnumber3)
```

```{r}
#install.packages("MuMIn")
library(MuMIn)

# Calculate marginal R-squared for `lmm_model_specnumber3`
specnumber3_marginal_r_squared <- r.squaredGLMM(lmm_model_specnumber3, mu0 = "fixed")
print(specnumber3_marginal_r_squared)
```


```{r}
#--------------------------------------------------------------
## Marginal R^2 for `Species` (using `lmm_model_specnumber3`)
#--------------------------------------------------------------

#install.packages("MuMIn")
library(MuMIn)

# Fit the linear mixed-effects model with just `Species`
lmm_model_specnumber_sp <- lmer(log(specnumber) ~ Species + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `Species`
specnumber_marginal_r_squared_sp <- r.squaredGLMM(lmm_model_specnumber_sp, mu0 = "fixed")
print(specnumber_marginal_r_squared_sp)
```


```{r}
#--------------------------------------------------------------
## Marginal R^2 for `GDD_5C` (using `lmm_model_specnumber3_month`)
#--------------------------------------------------------------

# Fit the linear mixed-effects model with just `Species`
lmm_model_specnumber_gdd <- lmer(log(specnumber) ~ GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `Species`
specnumber_marginal_r_squared_gdd <- r.squaredGLMM(lmm_model_specnumber_gdd, mu0 = "fixed")
print(specnumber_marginal_r_squared_gdd)
```


```{r}
#------------------------------------------------------------------------------------
## Marginal R^2 for `Species:GDD_5C` interaction only (using `lmm_model_specnumber3`)
#------------------------------------------------------------------------------------

# Fit the linear mixed-effects model with just `Species`
lmm_model_specnumber_interaction <- lmer(log(specnumber) ~ Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `Species`
specnumber_marginal_r_squared_interaction <- r.squaredGLMM(lmm_model_specnumber_interaction, mu0 = "fixed")
print(specnumber_marginal_r_squared_interaction)
```


Bootstrap CIs now???





```{r, message=FALSE, warning=FALSE}
library(stats)
#install.packages("agricolae")
library(agricolae)
```

```{r}
shapiro.test(asv_scaled_noPlants_Phen_filt_LMM$specnumber)

#p<0.05 --> thus, NOT normal; must do Kruskal-Wallis, followed by Wilcox pairwise comparisons
```

```{r}
kruskal.test(asv_scaled_noPlants_Phen_filt_LMM$specnumber~asv_scaled_noPlants_Phen_filt_LMM$Species)
```


In this case, the p-value is 0.2595. Since the p-value is greater than the common significance level of 0.05, we fail to reject the null hypothesis. Therefore, there is not enough evidence to suggest that there are significant differences in the medians of the groups based on the variable "specnumber" for the different levels of the "Species" variable.

In other words, the Kruskal-Wallis test does not provide strong evidence to conclude that the distributions of "specnumber" are significantly different among the different species in the dataset.

Please note that the Kruskal-Wallis test only tells you that there are differences among the groups, but it does not indicate which groups are different from each other. If you want to identify specific differences between groups, you may need to perform post hoc tests, such as the Dunn test or the Conover-Iman test, to make pairwise comparisons. These post hoc tests account for multiple comparisons and help identify which specific groups differ significantly from each other.



```{r, warning=FALSE}
pairwise.wilcox.test(asv_scaled_noPlants_Phen_filt_LMM$specnumber, asv_scaled_noPlants_Phen_filt_LMM$Species, p.adj="bonferroni")
```


Since the p-value (0.26) is greater than the significance level (commonly set at 0.05), we fail to reject the null hypothesis. Therefore, there is not enough evidence to suggest that there are significant differences in the distribution of "specnumber" between "Betula populifolia" and "Populus tremuloides."



```{r}
kruskal.test(asv_scaled_noPlants_Phen_filt_LMM$specnumber~asv_scaled_noPlants_Phen_filt_LMM$GDD_5C)
```


In this case, the p-value is 0.4491. Since the p-value is greater than the common significance level of 0.05, we fail to reject the null hypothesis. Therefore, there is not enough evidence to suggest that there are significant differences in the medians of the groups based on the variable "specnumber" for the different levels of the "GDDs" variable.

In other words, the Kruskal-Wallis test does not provide strong evidence to conclude that the distributions of "specnumber" are significantly different among the different GDDs in the dataset.



```{r}
pairwise.wilcox.test(
  x = asv_scaled_noPlants_Phen_filt_LMM$specnumber,
  g = asv_scaled_noPlants_Phen_filt_LMM$GDD_5C,
  p.adjust.method = "bonferroni",
  exact = FALSE,  # Disable exact p-value calculation
  correct = TRUE  # Apply continuity correction for ties
)
```


This just confirms the Kruskal-Wallis test.



```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(purrr)
```

```{r}
#For INTERspecific variation, we probably want to interaction p-value, so probably do it this way with Wilcox test like this:

# Group data by Growing-Degree-Days-5C and perform Wilcoxon test for each group
wilcox_specnumber <- asv_scaled_noPlants_Phen_filt_LMM %>%
  group_by(GDD_5C) %>%
  nest() %>%
  mutate(wilcox_specnumber = map(data, ~ wilcox.test(specnumber ~ Species, data = .x))) %>%
  mutate(p_value = map_dbl(wilcox_specnumber, ~ .x$p.value))

# Display the results
print(wilcox_specnumber)
```

**INTERPRETATION:**

Investigating the INTERspecific variation BETWEEN Betula_populifolia and Populus_tremuloides microbiomes ACROSS the full range of growing degree days (Growing-Degree-Days-5C), we conducted Wilcoxon rank-sum tests to examine the differences in alpha diversity (specnumber) between the two species. Our analysis revealed varying patterns across different levels of Growing-Degree-Days-5C. At the level of 605 Growing-Degree-Days-5C, we observed a statistically significant difference in alpha diversity between the two species (p-value = 0.00794). This indicates that Betula_populifolia and Populus_tremuloides microbiomes exhibit distinct alpha diversity profiles at this specific stage of phenological development. In contrast, at other levels of Growing-Degree-Days-5C, such as 1992 and 2140, we did not find statistically significant differences in alpha diversity between the two species (p-values = 0.421 and 1, respectively). These findings suggest that the interspecific variation in alpha diversity between Betula_populifolia and Populus_tremuloides is context-dependent, with significant differences observed at certain points in the phenological progression. These insights contribute to our understanding of how species interactions and environmental factors shape the microbiome dynamics in these two tree species.


################################################################################
### 3. Shannon Diversity:
################################################################################


```{r}
#-------------------------------------------------------------------------
# Homogeneity of Slopes faceted by 'Species'
#-------------------------------------------------------------------------

##NOTE: Homoegenity of slopes is just looking at the data but not the actual results, plus there are no error bars, so it's telling if there's potentially an interaction, but not definitely whether or not. Do NOT rely on this, especially b/c no error bars. Traditional ANCOVA moving away from this?

#-------------------------------------------------------------------------
# (a) x=`GDD_5C`
#-------------------------------------------------------------------------
#Untransformed:  

levels = c("Betula_populifolia", "Populus_tremuloides")
myplot_shannon <- ggplot(data = asv_scaled_noPlants_Phen_filt_LMM, aes(x=GDD_5C,
y=alphaDiv))+facet_grid(.~Species)+geom_point()
myplot_shannon <- myplot_shannon+
 stat_smooth(method = lm, se=FALSE)+
 stat_smooth(se=FALSE, color="red") +
 labs(
 y = expression(~alphaDiv),
 x = expression(~GDD_5C))
myplot_shannon
```


```{r}
#-------------------------------------------------------------------------
# (a) x=`GDD_5C`
#-------------------------------------------------------------------------

levels = c("Betula_populifolia", "Populus_tremuloides")
myplot_shannon <- ggplot(data = asv_scaled_noPlants_Phen_filt_LMM, aes(x=GDD_5C,
y=sqrt(alphaDiv)))+facet_grid(.~Species)+geom_point()
myplot_shannon <- myplot_shannon+
 stat_smooth(method = lm, se=FALSE)+
 stat_smooth(se=FALSE, color="red") +
 labs(
 y = expression(~alphaDiv),
 x = expression(~GDD_5C))
myplot_shannon
```



```{r}
library(ggplot2)

myplot_shannon2 <- ggplot(data = asv_scaled_noPlants_Phen_filt_LMM, aes(x = GDD_5C, y = sqrt(alphaDiv))) +
  facet_grid(. ~ Species) +
  geom_point() +
  stat_smooth(method = lm, se = FALSE) +
  stat_smooth(se = FALSE, color = "red") +
  labs(y = expression(~alphaDiv), x = expression(~GDD_5C)) +
  geom_text(
    aes(
      x = Inf, y = -Inf,
      label = paste("R-squared: ", round(summary(lm(sqrt(alphaDiv) ~ GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM))$r.squared, 3))
    ),
    hjust = 1, vjust = 0, color = "blue", size = 3
  )

myplot_shannon2
```



```{r, warning=FALSE}
#-------------------------------------------------------------------------
# Visualize data with a Scatterplot Matrix
#-------------------------------------------------------------------------

# To evaluate not only linearity, but also collinearity; r.e. lecture on Multiple Regression (lec. 16/17) slide 46

plot <- scatterplotMatrix(
  ~ alphaDiv + Species + GDD_5C,
  regLine = TRUE, smooth = TRUE, diagonal = TRUE,
  data = asv_scaled_noPlants_Phen_filt_LMM
)
```


```{r, message=FALSE, warning=FALSE}
# Install and load necessary packages
#install.packages("lmerTest")
#install.packages("lme4")
library(lmerTest)
library(lme4)

# Fit the linear mixed-effects model
lmm_model_shannon1 <- lmer(alphaDiv ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon1)
```


```{r}
# Fit the linear mixed-effects model
lmm_model_shannon2 <- lmer(sqrt(alphaDiv) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon2)
```


```{r}
# Fit the linear mixed-effects model
lmm_model_shannon2_plantid_month <- lmer(sqrt(alphaDiv) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID) + (1 | `Collection-Month`), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon2_plantid_month)
```


```{r}
# Fit the linear mixed-effects model
lmm_model_shannon2_month <- lmer(sqrt(alphaDiv) ~ Species + GDD_5C + Species:GDD_5C + (1 | `Collection-Month`), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon2_month)
```


```{r}
# Fit the linear mixed-effects model
lmm_model_shannon3 <- lmer(I(alphaDiv^2) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon3)
```


```{r}
# Fit the linear mixed-effects model
lmm_model_shannon4 <- lmer((1/alphaDiv) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon4)
```


```{r}
#-----------------------------------------------------------------------------
## ANCOVA
#-----------------------------------------------------------------------------

# Perform ANCOVA
ancova_shannon <- lm(sqrt(alphaDiv) ~ Species + GDD_5C + Species:GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM)

Anova(ancova_shannon, type=3)

summary(ancova_shannon)

#Adjusted R^2 = 0.3016
```


```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model.final2' with ANCOVA model:

anova(lmm_model_shannon1, lmm_model_shannon2, lmm_model_shannon3, lmm_model_shannon4, ancova_shannon, lmm_model_shannon2_month, lmm_model_shannon2_plantid_month)


# Slightly lower AIC and BIC for `lmm_model_shannon2` than `lmm_model_shannon2_month` with sqrt-transformation, higher logLik, and also lower deviance, etc. 
```

```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_shannon1)) # p=0.0001196 -> NOT Normal!
shapiro.test(residuals(lmm_model_shannon2)) # p=2.494e-07 -> Even LESS Normal!
shapiro.test(residuals(lmm_model_shannon3)) # p=0.259 -> Normal!
shapiro.test(residuals(lmm_model_shannon4)) # p=3.892e-15 -> WORST for Normality!
shapiro.test(residuals(ancova_shannon))     # p=0.0001316 -> NOT Normal
shapiro.test(residuals(lmm_model_shannon2_month)) # p=4.531e-07 -> NOT Normal
shapiro.test(residuals(lmm_model_shannon2_plantid_month)) # p=4.531e-07 -> NOT Normal


## Here, `lmm_model_shannon3` is the only model with normally distributed residuals.. but terrible residuals.
```

```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_shannon1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_shannon2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_shannon3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(lmm_model_shannon4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
check_model(ancova_shannon)

## `lmm_model_shannon1` and `lmm_model_shannon2` don't differ much; `lmm_model_shannon2` likely best still.

## For ANCOVA, residuals are terrible looking.

## Since AIC and BIC, plus others, are substantially better for `lmm_model_shannon2` than `lmm_model_shannon1`, we choose `lmm_model_shannon2` (square-root transformed).
```


```{r}
check_model(lmm_model_shannon2_month, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```

```{r}
check_model(lmm_model_shannon2_plantid_month, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


**NOTE:** `lmm_model_shannon2` (i.e., sqrt transformed) is best for diagnostics above.


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_shannon2 <- Anova(lmm_model_shannon2)
anova_lmm_shannon2_month <- Anova(lmm_model_shannon2_month)
anova_lmm_shannon2_plantid_month <- Anova(lmm_model_shannon2_plantid_month)

summary(anova_lmm_shannon2)
summary(anova_lmm_shannon2_month)
summary(anova_lmm_shannon2_plantid_month)

## Supports `lmm_model_shannon2` as best fit.
```


```{r}
################################################################################
## FINAL CHOICE: `lmm_model_shannon2` (sqrt transformed response variable)
################################################################################

# Fit the linear mixed-effects model
lmm_model_shannon2 <- lmer(sqrt(alphaDiv) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Obtain summary of the LMM with p-values
summary(lmm_model_shannon2)
```


```{r}
#install.packages("MuMIn")
library(MuMIn)

# Calculate marginal R-squared for `lmm_model_shannon2`
shannon2_marginal_r_squared <- r.squaredGLMM(lmm_model_shannon2, mu0 = "fixed")
print(shannon2_marginal_r_squared)
```


```{r}
#--------------------------------------------------------------
## Marginal R^2 for `Species`
#--------------------------------------------------------------

# Fit `lmm_model_shannon2` with just `Species`
lmm_model_shannon2_sp <- lmer(sqrt(alphaDiv) ~ Species + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `Species`
shannon2_marginal_r_squared_sp <- r.squaredGLMM(lmm_model_shannon2_sp, mu0 = "fixed")
print(shannon2_marginal_r_squared_sp)
```


```{r}
#--------------------------------------------------------------
## Marginal R^2 for `GDD_5C`
#--------------------------------------------------------------

# Fit `lmm_model_shannon2` with just `GDD_5C`
lmm_model_shannon2_gdd <- lmer(sqrt(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `GDD_5C`
shannon2_marginal_r_squared_gdd <- r.squaredGLMM(lmm_model_shannon2_gdd, mu0 = "fixed")
print(shannon2_marginal_r_squared_gdd)
```


```{r}
#--------------------------------------------------------------
## Marginal R^2 for `Species:GDD_5C` interaction
#--------------------------------------------------------------

# Fit `lmm_model_shannon2` with just `Species:GDD_5C` interaction
lmm_model_shannon2_int <- lmer(sqrt(alphaDiv) ~ Species:GDD_5C + (1 | Plant_ID), data = asv_scaled_noPlants_Phen_filt_LMM)

# Calculate marginal R-squared for `Species:GDD_5C` interaction
shannon2_marginal_r_squared_int <- r.squaredGLMM(lmm_model_shannon2_int, mu0 = "fixed")
print(shannon2_marginal_r_squared_int)
```





- Shapiro Test  (comparing independent groups wiht Shannon/ASV richness, must check if normally distrib.) --> Only specify column in which dataset is in (shaphiro.test(column), will only do on just one column); if normal, do ANOVA.

- If not normal, Kruskal-Wallis test --> equivalence of ANOVA with non-parametric data. DO NOT use Tukey HSD, there is one that is equiavlent for non-parametric (can't recall name).

- In this case, once ANOVA is done, want to look at pairwise comparison --> this just says variance differs b/w groups, but don't know where diffs are --> need Tukey HSD for ANOVA.



```{r}
shapiro.test(asv_scaled_noPlants_Phen_filt_LMM$alphaDiv)
```


Since p>0.05 means it IS normally distrib, then we would do ANOVA (parametric test). 

But, if we are stricter/conservative and say it is NOT normally distrib., b/c p>0.05 is violated here, then we need a non-parametric method (e.g., Wilcox Test).


- For GDDs = NOT a continuous variable, would only do normality test for response variable (richness, shannon), but for GDDs, doesn't work???


```{r}
# Perform ANOVA
anova_result_shannon <- aov(alphaDiv ~ Species*GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM)

# Summarize the ANOVA results
summary(anova_result_shannon)
```



Tukey HSD Post-Hoc Test:


```{r}
# Perform Tukey HSD test
tukey_result_species <- TukeyHSD(aov(alphaDiv ~ Species, data = asv_scaled_noPlants_Phen_filt_LMM))

# Print the Tukey HSD test result
print(tukey_result_species)
```


```{r, eval=FALSE}
# Perform Tukey HSD test
tukey_result_gdd <- TukeyHSD(aov(alphaDiv ~ GDD_5C_bins, data = asv_scaled_noPlants_Phen_filt_LMM))

# Print the Tukey HSD test result
print(tukey_result_gdd)

##NOTE: Warning: non-factors ignored: GDD_5CError in TukeyHSD.aov(aov(alphaDiv ~ GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM)) : 
#  no factors in the fitted model

#Can't do Tukey with GDD_5C b/c NOT categorical!
```


```{r}
# Perform pairwise comparisons
pairwise_gdd <- pairwise.t.test(asv_scaled_noPlants_Phen_filt_LMM$alphaDiv, asv_scaled_noPlants_Phen_filt_LMM$GDD_5C, p.adjust.method = "bonferroni")

# View the results
print(pairwise_gdd)
```



```{r}
# Group data by Growing-Degree-Days-5C and perform t-test for each group
t_test_shannon <- asv_scaled_noPlants_Phen_filt_LMM %>%
  group_by(GDD_5C) %>%
  nest() %>%
  mutate(t_test_shannon = map(data, ~ t.test(alphaDiv ~ Species, data = .x))) %>%
  mutate(p_value = map_dbl(t_test_shannon, ~ .x$p.value))

# Display the results
print(t_test_shannon)
```



**INTERPRETATION:** 

1. ANOVA Results:

- In the ANOVA summary, you have assessed the overall significance of the Species and Growing-Degree-Days-5C variables and their interaction term (Species:Growing-Degree-Days-5C) in explaining the variation in the alphaDiv` variable.

- The ANOVA results show that Species is highly significant (p < 0.001), indicating that there are significant differences in alphaDiv between different species.

- However, the Growing-Degree-Days-5C variable is not significant (p = 0.702), suggesting that it does not have a significant effect on alphaDiv.

- The interaction term (Species:Growing-Degree-Days-5C) is also not significant (p = 0.565), indicating that the effect of Speciesdoes not significantly vary across different levels ofGrowing-Degree-Days-5C`.
Post hoc T-Tests:

2. In the post hoc t-tests, it's a different approach. 

- Instead of looking at the overall significance of Growing-Degree-Days-5C, you have conducted individual t-tests for each level of Growing-Degree-Days-5C to compare alphaDiv between species within each level.

- The results of these t-tests provide p-values for each level of Growing-Degree-Days-5C, indicating whether there are significant differences in alphaDiv between species within those levels.

- Interestingly, some of the t-tests show significant p-values (e.g., p = 0.032984190, p = 0.002218572, etc.), suggesting that there are significant differences between species in certain levels of Growing-Degree-Days-5C.

**Results:**

The analysis aimed to investigate the variation in leaf microbiome Shannon diversity (alphaDiv) between two host tree species, Betula populifolia and Populus tremuloides, over the course of phenology, as measured by Growing-Degree-Days-5C (GDD-5C).

1. Overall Effects of Species and Phenology

- The analysis began by performing an Analysis of Variance (ANOVA) to assess the overall significance of the Species and GDD-5C variables, as well as their interaction.

- The results of the ANOVA indicated that Species had a highly significant effect on alphaDiv (F = 32.522, p < 0.001). This suggests that there are significant differences in leaf microbiome Shannon diversity between Betula populifolia and Populus tremuloides.

- However, the GDD-5C variable was not statistically significant (F = 0.635, p = 0.702), implying that phenological stages, as measured by GDD-5C, did not have a significant impact on alphaDiv.

- The interaction term between Species and GDD-5C was also not significant (F = 0.811, p = 0.565), indicating that the effect of Species on alphaDiv did not vary significantly across different phenological stages.

2. Post hoc Tests

- In order to gain deeper insights into the variations observed, post hoc t-tests were conducted for each level of GDD-5C, comparing alphaDiv between Betula populifolia and Populus tremuloides within these phenological stages.

- Notably, some specific levels of GDD-5C exhibited significant differences in alphaDiv between the two tree species. For instance, at GDD-5C level 437, a significant difference was observed (p = 0.032984190). Likewise, at GDD-5C level 605, the difference was highly significant (p = 0.002218572).

- However, in some other phenological stages (e.g., GDD-5C level 1606), there were no significant differences in alphaDiv between Betula populifolia and Populus tremuloides (p = 0.664995409).

3. Interpretation

- These findings suggest that while the overall effect of GDD-5C on leaf microbiome Shannon diversity was not significant, there are specific phenological stages where differences between Betula populifolia and Populus tremuloides do exist. These differences could be related to various ecological factors specific to those phenological stages.

4. Considerations and Implications

- It is essential to consider factors such as sample size and the ecological context when interpreting these results.

- These findings may have implications for understanding the dynamics of leaf microbiomes in Betula populifolia and Populus tremuloides and could inform future research in plant-microbiome interactions.

In summary, this analysis reveals that the two tree species, Betula populifolia and Populus tremuloides, exhibit significant differences in leaf microbiome Shannon diversity. While phenological stages, as measured by GDD-5C, did not show an overall impact on alphaDiv, specific stages did exhibit significant variations between the two species. These findings provide valuable insights into the ecological dynamics of leaf microbiomes in these host trees.


## Tukey HSD (LMM):

```{r, eval=FALSE}
#Post-hoc LMM comparisons (Tukey HSD):

library(emmeans)

emm_shannon <- emmeans(lmm_model_shannon2, "Species")

pairwise_comparisons_shannon_tukey <- pairs(emm_shannon, adjust = "tukey")

summary(pairwise_comparisons_shannon_tukey)
```

OR:

## Dunnett's Test:

```{r, eval=FALSE}
# Assuming "Control_Species" is the reference level
pairwise_comparisons_shannon_dunnett_sp <- emmeans(lmm_model_shannon2, pairwise ~ Species, contr = "Dunnett")

pairwise_comparisons_shannon_dunnett_gdd <- emmeans(lmm_model_shannon2, pairwise ~ GDD_5C, contr = "Dunnett")

summary(pairwise_comparisons_shannon_dunnett_sp)
summary(pairwise_comparisons_shannon_dunnett_gdd)
```

## Marginal R^2:


```{r}
#install.packages("MuMIn")
library(MuMIn)

# Calculate marginal R-squared
shannon_marginal_r_squared <- r.squaredGLMM(lmm_model_shannon2, mu0 = "fixed")
print(shannon_marginal_r_squared)
```


## emmeans; CAN'T GET TO WORK!

```{r, eval=FALSE}
#install.packages("emmeans")
library(emmeans)

# Estimate marginal means for alphaDiv
shannon_means <- emmeans(lmm_model_shannon2, ~ Species * GDD_5C)

# Perform pairwise comparisons within each combination of Species and Growing-Degree-Days-5C
shannon_comparisons <- pairs(shannon_means, by = c("Species", "GDD_5C"))

# Display the results
summary(shannon_comparisons)
```


**INTERPRETATION:**

Interpretation of the LMM results in the context of interspecific variation between Betula and Populus across growing degree days:

**1. Species Effect:**

- The coefficient for the species effect of "SpeciesPopulus_tremuloides" is estimated to be 0.90267, with a standard error of 0.20142. This coefficient is statistically significant (p-value = 0.00206), which indicates that there is a significant difference in the average alpha diversity (represented by alphaDiv) between Betula and Populus species.

Interpretation: On average, Populus species exhibit approximately 0.90267 units higher alpha diversity compared to Betula species. This suggests that the two species differ significantly in their alpha diversity levels.

**2. Growing Degree Days Effect:**

- The coefficients for the different levels of "Growing-Degree-Days-5C" (605, 1087, 1606, 1992, 2140, 2219) represent the effect of each specific growing degree day on alpha diversity. However, none of these coefficients are statistically significant (all p-values > 0.05).

Interpretation: The model does not find a significant linear relationship between individual growing degree days and alpha diversity. This implies that changes in growing degree days are not strongly associated with variations in alpha diversity.

**3. Interaction Effect:**

- The coefficients representing the interactions between species and growing degree days (e.g., "SpeciesPopulus_tremuloides:Growing-Degree-Days-5C605") are not statistically significant for any of the growing degree day levels (all p-values > 0.05).

Interpretation: The model does not identify significant variations in the relationship between species (Betula vs. Populus) and alpha diversity across different growing degree days. This suggests that the difference in alpha diversity between the two species remains relatively consistent across the range of growing degree days.

**4. Random Effects:**

- The model includes random intercepts for individual plant IDs, capturing the variability in alpha diversity that cannot be explained by the fixed effects. These random intercepts help account for repeated measures within the same plant.

**5. Overall Model Fit:**

The model's R-squared value of 0.4193 indicates that approximately 41.93% of the total variability in alpha diversity can be explained by the fixed effects included in the model.

In summary, the linear mixed-effects model (LMM) reveals that there is a significant difference in alpha diversity between Betula and Populus species. However, changes in growing degree days do not have a significant linear relationship with alpha diversity, and the interaction between species and growing degree days is not significant. This suggests that the interspecific variation in alpha diversity between Betula and Populus is consistent across the range of growing degree days considered in the analysis.



**OVERALL Interpretation:**

Analysis of the linear mixed-effects model (LMM) examining interspecific variation in alpha diversity between Betula and Populus species across growing degree days revealed noteworthy insights. The coefficient for the species effect of Populus tremuloides demonstrated statistical significance (p-value = 0.00206), indicating a substantial difference in average alpha diversity between the two species. Specifically, Populus tremuloides displayed approximately 0.90267 units higher alpha diversity compared to Betula species. This species-related disparity underscores the role of species identity in shaping alpha diversity patterns.

In contrast, the individual coefficients representing the effect of various growing degree days (605, 1087, 1606, 1992, 2140, 2219) did not exhibit statistical significance (all p-values > 0.05), suggesting that changes in growing degree days are not strongly associated with variations in alpha diversity. Moreover, the interaction coefficients between species and growing degree days were not significant across any of the growing degree day levels (all p-values > 0.05), indicating that the interspecific difference in alpha diversity between Betula and Populus remains consistent across the range of growing degree days considered.

The inclusion of random intercepts for individual plant IDs accounted for unexplained variability in alpha diversity within the model. The model's R-squared value of 0.4193 indicates that approximately 41.93% of the total variability in alpha diversity can be attributed to the fixed effects integrated into the model. Overall, the LMM provides valuable insights into the factors influencing interspecific variation in alpha diversity. While species identity exerts a substantial influence, the analysis suggests that growing degree days may not play a significant role in shaping this particular aspect of diversity for these species.

These findings offer a nuanced understanding of the intricate dynamics contributing to alpha diversity patterns between Betula and Populus species. While the species effect emerges as a prominent driver of variation, the lack of significant growing degree days effects and interaction terms underscores the importance of considering other ecological factors that might contribute to the observed patterns.


################################################################################
## AT WHICH GDD DOES ALPHA DIVERSITY VARY MOST WITHIN & BETWEEN HOSTS?
## WHERE IS IT MOST STABLE?
################################################################################

   
################################################################################
## ALPHA DIVERSITY (INTERSPECIFIC) - NEW STATS METHODS DISCUSSED WITH ITUMELENG!!!
################################################################################

Since we treat `GDD_5C` as a continuous variable, & we're having trouble doing pairwise comparisons and post-hocs (b/c you can't do that on a continuous variable like `GDD_5C`), the LMMs don't really help us see at which GDDs the two `Species` vary the MOST b/w one another, and which GDDs are most impactful. 

So now, we will ONLY do (1) ASV Richness & (2) Shannon Index, but NOT Simpson to simplify things for ALPHA DIVERSITY. 

**New Method:** Subset `asv_scaled_noPLants_Phen_filt_LMM` by each `GDD_5C`, so then we have a dataset for each `GDD_5C`. 
- Then, for each, test Normality of `specnumber` (ASV richness) and `alphaDiv` (Shannon index) -> if normal, then do ANOVA; if non-normal, do non-parametric method. 

**NOTE:** BOTH the biostats professor AND Itumeleng are correct, & I misunderstood. The biostats prof assumed that I already chose to do LMMs, so since we're testing Normality on a MODEL, we have to test Normality of residuals (i.e., shapiro.test(residuals(lmm_model))). I initially chose LMMs because it included both `Species`, `GDD_5C`, and their interaction, BUT it did NOT answer the question of: "At which GDD values do the host species vary the most?" This is why we subset now by `GDD_5C`, b/c it allows us to eliminate that continuous GDD variable from the equation, then we can just compare each GDD subset!

SO, Itumeleng was also correct because his method HASN'T chosen a model yet!!
- It's ok to test the Normality of a variable directly here, b/c we are doing that TO choose a model (i.e., either ANOVA or non-parametric), so we can do: shapiro.test(asv_437$specnumber)

**In Other Words:**

The confusion arises from the context in which normality tests are applied. Both your biostatistics professor and the advice provided here are correct, but they apply to different stages of the analysis process.

1. Testing Normality of Residuals in LMMs: When you have a Linear Mixed Model (LMM) and you want to assess whether the residuals of your model are normally distributed, it is appropriate to use shapiro.test(residuals(lmm_model)). This is because the residuals are the differences between the observed values and the values predicted by the model. Testing the normality of these residuals directly addresses the assumption of normality in the residuals, which is crucial for the validity of many statistical tests and model assumptions.

2. Testing Normality of Variables Before Modeling: Before you fit an LMM or any other model, you might want to test the normality of your variables to inform your choice of model. For example, if you're considering using ANOVA, you might first test the normality of your variables with shapiro.test(asv_437$Diversity) or shapiro.test(asv_437$Species). This is because ANOVA assumes that the data are normally distributed. However, this is a preliminary check and does not replace the need to test the normality of residuals after modeling, especially in the context of LMMs.

3. Choosing Between Parametric and Non-parametric Methods: Based on the normality test results, you can decide whether to use parametric (e.g., ANOVA) or non-parametric methods. If the residuals are normally distributed, you can proceed with parametric tests. If not, non-parametric methods might be more appropriate. This decision is based on the normality of the residuals, not the variables themselves.

4. Diagnostic Checks for LMMs: When using LMMs, it's important to perform diagnostic checks to ensure the model's assumptions are met. This includes checking for linearity, homoscedasticity, and the independence of residuals. These checks are specific to LMMs and help ensure the model's validity 2.

In summary, both the biostatistics professor and the advice provided here are correct in their contexts. Testing the normality of residuals in the context of an LMM is crucial for assessing the model's validity. Testing the normality of variables before modeling can inform your choice of model but does not replace the need to test the normality of residuals after modeling. The decision to use parametric or non-parametric methods should be based on the normality of the residuals, not the variables themselves.

**Steps:**

1. Test normality of data itself [e.g. shapiro.test(asv_437$specnumber)]
2. If normal, then use ANOVA; if non-normal, use non-parametric Kruskal-Wallis
3. IF you choose ANOVA, there's an assumption of normality, so you still have to test Normality of Residuals of ANOVA (but NOT Kruskal/non-parametric, since it does NOT assume normality), so if ANOVA is chosen, have to do: shapiro.test(residuals(anova_model). 

```{r}
#Subset data by GDD
alpha_437 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 437)
alpha_605 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 605)
alpha_1087 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 1087)
alpha_1606 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 1606)
alpha_1992 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 1992)
alpha_2140 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 2140)
alpha_2219 <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == 2219)
```

################################################################################
# 1. ASV Richness
################################################################################

(a) GDD 437#####################################################################

```{r}
shapiro.test(alpha_437$specnumber)

# p = 0.8189 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_specnumber_437 <- aov(specnumber ~ Species, data = alpha_437)

# Summarize the ANOVA results
summary(anova_specnumber_437)
```


```{r}
#Check Normality of Residuals & other diagnostic stats (Levene Test, Q-Q plots, Residuals vs. Fitted)?

#Normality of Residuals:
shapiro.test(residuals(anova_specnumber_437)) #p=0.204>0.05 --> Normality good!

#Levene's Test? Q-Q? Residuals vs Fitted?
```


THEREFORE: There is NO significant difference in the ASV richness between the two host tree species at GDD 437 (p=0.43)!


(b) GDD 605#####################################################################

```{r}
shapiro.test(alpha_605$specnumber)

# p = 0.6105 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_specnumber_605 <- aov(specnumber ~ Species, data = alpha_605)

# Summarize the ANOVA results
summary(anova_specnumber_605)
```


```{r}
#Check Normality of Residuals & other diagnostic stats (Levene Test, Q-Q plots, Residuals vs. Fitted)?

#Normality of Residuals:
shapiro.test(residuals(anova_specnumber_605)) #p=0.0752>0.05 --> Normality good!

#Levene's Test? Q-Q? Residuals vs Fitted?
```

THEREFORE: There IS a significant difference between the two host species at GDD 605 (p=0.00615)!


(c) GDD 1087####################################################################


```{r}
shapiro.test(alpha_1087$specnumber)

# p = 0.02871 < 0.05 --> it is NOT NORMAL, so do non-parametric Kruskal-Wallis
```


```{r}
kruskal.test(alpha_1087$specnumber~alpha_1087$Species)
```


```{r}
#NOTE: No need to test normality of model, b/c Kruskal-Wallis is specifically for non-normality and assumes such. 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```


THEREFORE: There is NO significant difference in ASV richness between the two host species at GDD 1087 (p=0.1003)!


(d) GDD 1606####################################################################

```{r}
shapiro.test(alpha_1606$specnumber)

# p = 0.01982 < 0.05 --> it is NOT NORMAL, so do non-parametric Kruskal-Wallis
```


```{r}
kruskal.test(alpha_1606$specnumber~alpha_1606$Species)
```


```{r}
#NOTE: No need to test normality of model, b/c Kruskal-Wallis is specifically for non-normality and assumes such. 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There is NO significant difference in ASV richness between the two host species at GDD 1606 (p=0.6752)!


(e) GDD 1992####################################################################

```{r}
shapiro.test(alpha_1992$specnumber)

# p = 0.04133 < 0.05 --> it is NOT NORMAL, so do non-parametric Kruskal-Wallis
```


```{r}
kruskal.test(alpha_1992$specnumber~alpha_1992$Species)
```


```{r}
#NOTE: No need to test normality of model, b/c Kruskal-Wallis is specifically for non-normality and assumes such. 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```


THEREFORE: There is NO significant difference in ASV richness between the two host species at GDD 1992 (p=0.3472)!


(f) GDD 2140####################################################################

```{r}
shapiro.test(alpha_2140$specnumber)

# p = 0.6897 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_specnumber_2140 <- aov(specnumber ~ Species, data = alpha_2140)

# Summarize the ANOVA results
summary(anova_specnumber_2140)
```


```{r}
#Check Normality of Residuals & other diagnostic stats (Levene Test, Q-Q plots, Residuals vs. Fitted)?

#Normality of Residuals:
shapiro.test(residuals(anova_specnumber_2140)) #p=0.7048>0.05 --> Normality good!

#Levene's Test? Q-Q? Residuals vs Fitted?
```
THEREFORE: There is NO significant difference in ASV richness between the two host species at GDD 2140 (p=0.91)!


(g) GDD 2219####################################################################

```{r}
shapiro.test(alpha_2219$specnumber)

# p = 0.469 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_specnumber_2219 <- aov(specnumber ~ Species, data = alpha_2219)

# Summarize the ANOVA results
summary(anova_specnumber_2219)
```


```{r}
#Check Normality of Residuals & other diagnostic stats (Levene Test, Q-Q plots, Residuals vs. Fitted)?

#Normality of Residuals:
shapiro.test(residuals(anova_specnumber_2219)) #p=0.4304>0.05 --> Normality good!

#Levene's Test? Q-Q? Residuals vs Fitted?
```
THEREFORE: There is NO significant difference in ASV richness between the two host species at GDD 2219 (p=0.899)!


################################################################################
## 2. SHANNON DIVERSITY
################################################################################

(a) GDD 437#####################################################################

```{r}
shapiro.test(alpha_437$alphaDiv)

# p = 0.07414 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_437 <- aov(alphaDiv ~ Species, data = alpha_437)

# Summarize the ANOVA results
summary(anova_shannon_437)
```


```{r}
#Formal Test of Normality of Residuals

shapiro.test(residuals(anova_shannon_437))

#p=0.06265 which is technically >0.05, so residuals NOT normal... However, it's so close to 0.05, and since `alphaDiv` response variable is normally distributed, we can likely rely on ANOVA results. 
```

THEREFORE: There IS a significant difference in Shannon diversity between the two host species at GDD 437 (p=0.0165)!


(b) GDD 605#####################################################################

```{r}
shapiro.test(alpha_605$alphaDiv)

# p = 0.6194 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_605 <- aov(alphaDiv ~ Species, data = alpha_605)

# Summarize the ANOVA results
summary(anova_shannon_605)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_605)) #p=0.3227 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There IS  significant difference in Shannon diversity between the two host species at GDD 605 (p=0.00222)!


(c) GDD 1087#####################################################################

```{r}
shapiro.test(alpha_1087$alphaDiv)

# p = 0.6356 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_1087 <- aov(alphaDiv ~ Species, data = alpha_1087)

# Summarize the ANOVA results
summary(anova_shannon_1087)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_1087)) #p=0.7229 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There is NO significant difference in Shannon diversity between the two host species at GDD 1087 (p=0.101)!


(d) GDD 1606#####################################################################

```{r}
shapiro.test(alpha_1606$alphaDiv)

# p = 0.4786 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_1606 <- aov(alphaDiv ~ Species, data = alpha_1606)

# Summarize the ANOVA results
summary(anova_shannon_1606)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_1606)) #p=0.3012 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There is NO significant difference in Shannon diversity between the two host species at GDD 1606 (p=0.665)!


(e) GDD 1992#####################################################################

```{r}
shapiro.test(alpha_1992$alphaDiv)

# p = 0.3228 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_1992 <- aov(alphaDiv ~ Species, data = alpha_1992)

# Summarize the ANOVA results
summary(anova_shannon_1992)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_1992)) #p=0.3006 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There is NO significant difference in Shannon diversity between the two host species at GDD 1992 (p=0.185)!


(f) GDD 2140#####################################################################

```{r}
shapiro.test(alpha_2140$alphaDiv)

# p = 0.2041 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_2140 <- aov(alphaDiv ~ Species, data = alpha_2140)

# Summarize the ANOVA results
summary(anova_shannon_2140)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_2140)) #p=0.08083 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There IS a significant difference in Shannon diversity between the two host species at GDD 2140 (p=0.00553)!


(g) GDD 2219#####################################################################

```{r}
shapiro.test(alpha_2219$alphaDiv)

# p = 0.79 > 0.05 --> it is NORMAL, so do ANOVA
```


```{r}
# Perform ANOVA
anova_shannon_2219 <- aov(alphaDiv ~ Species, data = alpha_2219)

# Summarize the ANOVA results
summary(anova_shannon_2219)
```


```{r}
#Normality of Residuals:

shapiro.test(residuals(anova_shannon_2219)) #p=0.436 > 0.05 --> it's Normal! 

#Levene Test?
#Q-Q Plots?
#Residuals vs. Fitted
```

THEREFORE: There IS a significant difference in Shannon diversity between the two host species at GDD 2219 (p=0.00752)!



**!!!PLEASE READ!!!**

**NOTE:** We do BOTH the separate ANOVAs & the LMMs!! Here's why:

I asked Phind: "OK, so I did the method suggested by my collaborator, where I subset my data into the 7 GDD sampling points (since GDD is continuous). So, for each subset, I looked at whether or not the host `Species` identity variable significantly impacted bacterial diversity (checked normality of variable, either did paramteric ANOVA or non-parametric Kruskal-Wallis, then checked residuals). However, although I can see where the biggest differences are between species GDD-wise, this method doesn't tell me the impact of GDD on bacterial diversity, just host `Species`, right? Like, since I subset and get rid of the problem of the continuous GDD variable and not being able to do pairwise comparisons, but now I don't see how to see the impact `GDD` has on bacterial diversity, right? So, is this where I would then also include my LMMs and refer to those, since their equation is:

Diversity ~ Species + GDD + Species:GDD

So, I can see where the biggest differences between species are with my collaborator's method (e.g., `Species` most significantly impacts bacterial diversity at GDD 605), but I can't see the impact of GDDs themselves, right? So would I then include LMMs too for that p-value of GDD and Species:GDD? If so, this would just tell me overall the impact of GDD, right? Which is fine, since GDD is continuous anyway, right?"

ANSWER: Yes, your understanding is correct. By subsetting your data into the 7 GDD sampling points and analyzing the impact of Species on Diversity using either ANOVA or Kruskal-Wallis, you've effectively addressed the issue of the continuous GDD variable and its impact on the outcome variable Diversity. This approach allows you to examine the differences in Diversity between species at each GDD level. However, as you've noted, this method does not directly assess the impact of GDD itself on Diversity across all species.

To analyze the impact of GDD on Diversity across all species, incorporating GDD as a continuous variable into your model is indeed the appropriate approach. The inclusion of GDD and its interaction with Species (Species:GDD) in a Linear Mixed Model (LMM) allows you to examine the main effects of GDD and Species on Diversity, as well as the interaction effect between GDD and Species. This can provide insights into how GDD affects Diversity and whether this effect varies by species.

The equation you've mentioned, Diversity ~ Species + GDD + Species:GDD, is a good starting point for this analysis. This model will allow you to:

Assess the main effects of Species and GDD on Diversity.
Examine the interaction between Species and GDD on Diversity.
The p-value for GDD and Species:GDD in your LMM will indicate whether GDD has a significant effect on Diversity and whether this effect varies by species. If the p-value for GDD is significant, it suggests that GDD has a direct impact on Diversity. If the p-value for Species:GDD is significant, it indicates that the effect of GDD on Diversity varies by species.

In summary, while your collaborator's method allows you to examine the differences in Diversity between species at each GDD level, incorporating GDD and its interaction with Species into an LMM is the correct approach to analyze the overall impact of GDD on Diversity and how this impact varies by species.

ALSO, we do ANOVAs/Kruskals separate from LMMs! So, 2-Step Approach:

Our approach is correct and aligns well with the goals of our analysis. Here's a summary of your plan:

1. Analyzing Species-Driven Differences at Each GDD: By using ANOVA or Kruskal-Wallis models for each subset of your data corresponding to the 7 GDD sampling points, you're effectively examining how the identity of the host Species impacts bacterial diversity (Diversity) at each GDD level. This method allows you to identify where species exert the most effect on diversity across different GDD levels.

2. Assessing the Overall Impact of Species, GDD, and Their Interaction on Diversity: By incorporating GDD as a continuous variable and its interaction with Species into a Linear Mixed Model (LMM), you're addressing the broader question of how GDD affects Diversity across all species and whether this effect varies by species. The equation Diversity ~ Species + GDD + Species:GDD in your LMM will help you understand the main effects of Species and GDD on Diversity, as well as the interaction between Species and GDD.

This two-step approach is appropriate for our analysis. The first step provides insights into species-driven differences at each GDD level, while the second step offers a comprehensive view of the overall impact of GDD and its interaction with Species on Diversity. This combination of analyses allows you to explore both the specific effects of species at different GDD levels and the broader effects of GDD and its interaction with Species on bacterial diversity.



################################################################################
## BETA DIVERSITY
################################################################################


---- Code (Itumeleng) for BETA DIVERSITY Stats and Dispersion!?----


install.packages("SoDA")
install.packages("ecodist")


```{r, message=FALSE, warning=FALSE}
library(RColorBrewer)
library(ggplot2)
library(cowplot)
library(ggsignif)
library(ggpubr)
library(ggplot2)
library(ggpubr)
library(tidyverse)
library(vegan)
library(olsrr)
library(ggsignif)
library(lattice)
library(permute)
library(Hmisc)
#library(SoDA) #Doesn't exist anymore?
library(ecodist)
```



For Species:


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)

phen.disper.spp= betadisper(dist.mat, asv_scaled_noPlants_Phen_filt_LMM$Species, type = "centroid")

phen.disper.spp
summary(phen.disper.spp)
```


```{r}
permutest(phen.disper.spp, permutations = 999)
```


```{r}
anova(phen.disper.spp)
```


```{r}
plot(phen.disper.spp)
```


```{r}
boxplot(phen.disper.spp, xlab= "Species")
```


```{r}
TukeyHSD(phen.disper.spp) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.spp))
```



### For GDDs:


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)
phen.disper.gdd= betadisper(dist.mat, asv_scaled_noPlants_Phen_filt_LMM$GDD_5C, type = "centroid")

phen.disper.gdd
summary(phen.disper.gdd)

#NOTE: The betadisper function calculates the multivariate dispersion (variability) within each group of the categorical variable (Growing-Degree-Days-5C).
```


```{r}
permutest(phen.disper.gdd, permutations = 999)

#NOTE:The permutest function performs a permutation test to assess the significance of the F-statistic from the betadisper analysis. The results include the number of permutations (N.Perm) performed and the p-value (Pr(>F)) associated with the permutation test. In this case, the p-value is 0.953, indicating that the F-value is not significant.
```


```{r}
anova(phen.disper.gdd)

#The anova function provides an ANOVA-like analysis of the dispersion values among the groups.
#Groups F: The F-statistic for testing the null hypothesis of equal dispersion among the groups. The F-value is 0.2429.
#Groups Pr(>F): The p-value associated with the F-statistic. In this case, the p-value is 0.9604, indicating that the differences in dispersion among groups are not statistically significant.
```


```{r}
plot(phen.disper.gdd)
```


```{r}
boxplot(phen.disper.gdd, xlab= "Growing Degree Days")
```


```{r}
TukeyHSD(phen.disper.gdd) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.gdd))
```


```{r}
#Influence taxonomic composition on betadiveristy by Species

phen.spp.adonis2<- adonis2(dist.mat ~ asv_scaled_noPlants_Phen_filt_LMM$Species, perm = 999) #Calculate influence of treatment using community  matrix

phen.spp.adonis2
```


```{r}
#Influence taxonomic composition on betadiveristy by GDDs

phen.gdd.adonis2<- adonis2(dist.mat ~ asv_scaled_noPlants_Phen_filt_LMM$GDD_5C, perm = 999) #Calculate influence of treatment using community  matrix

phen.gdd.adonis2
```



## COMBINE RESULTS FOR BOTH GDDs AND SPECIES:


```{r}
#1. Multidispersion Analysis for Interaction (Species & GDDs):

# Calculate multidispersion considering interaction
phen.disper.interact <- betadisper(dist.mat, 
                                   interaction(asv_scaled_noPlants_Phen_filt_LMM$Species, 
                                               asv_scaled_noPlants_Phen_filt_LMM$GDD_5C),
                                   type = "centroid")

#2. Permutation Test for Interaction:
permutest(phen.disper.interact, permutations = 999)
```


```{r}
#3. ANOVA-Like Analysis for Interaction:
anova(phen.disper.interact)
```


```{r}
plot(phen.disper.interact)
```


```{r}
#Post-hoc Pairwise Comparisons for Interaction

pairwise_dispersion_interact <- TukeyHSD(phen.disper.interact)

head(pairwise_dispersion_interact)
```


- have in-group - b/w-group differences --> adonis() only tells b/w group variation.

- but with biological variation, within-group variation is sometimes larger than b/w-group, & when this happens, it means the species composition in the group explain the observed differences, not due to the effect.

- if see a lot of spread in data, within-group variation is much larger with PERMANOVA than b/w, the observed diff is not b/c factor but b/c of species composition (of microbes within each group). The difference within-group will be bigger driver than b/w group in this case.

- If dispersion within-group is non-significant, the diffs b/w-group is the driving/more impactful.



## PERMANOVA (BETA DIVERSITY)

```{r}
# Perform PERMANOVA with interaction term
permanova_beta1 <- adonis2(dist.mat ~ Species + GDD_5C + Species:GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM, permutations = 999)

# Print the PERMANOVA results
print(permanova_beta1)
```

```{r}
# Perform PERMANOVA with interaction term
permanova_beta <- adonis2(dist.mat ~ Species * GDD_5C, data = asv_scaled_noPlants_Phen_filt_LMM, permutations = 999)

# Print the PERMANOVA results
print(permanova_beta)
```


## Pairwise PERMANOVA 


```{r, message=FALSE, warning=FALSE}
#install.packages("lmPerm")
#install.packages("RVAideMemoire")
library(RVAideMemoire)
library(lmPerm)
library(vegan)
```


THIS IS NOT CORRECT; FIGURE IT OUT:
```{r}
gdd_levels <- unique(asv_scaled_noPlants_Phen_filt_LMM$GDD_5C)

# Initialize a list to store pairwise results
pairwise_results_beta_list <- list()

# Loop through GDD levels
for (gdd_level in gdd_levels) {
  
  # Subset the data by GDD level
  subset_data <- subset(asv_scaled_noPlants_Phen_filt_LMM, GDD_5C == gdd_level)
  
  # Perform pairwise PERMANOVA for Species within each GDD level
  pairwise_results_beta <- pairwise.perm.manova(dist.mat, subset_data$Species, nperm = 999)
  
  # Store the results in the list
  pairwise_results_beta_list[[as.character(gdd_level)]] <- pairwise_results_beta
}

# Print or analyze the results in pairwise_results_list
print(pairwise_results_beta_list)
```



**INTERPRETATION (Pairwise PERMANOVA:**

IF CORRECTLY DONE:

Investigating interspecific variation between Betula_populifolia and Populus_tremuloides across different growing degree days revealed significant differences in microbiome compositions. Pairwise PERMANOVA comparisons were performed to assess the dissimilarity between the two species within each specific growing degree day. The results indicated varying levels of dissimilarity between Betula_populifolia and Populus_tremuloides microbiomes at different stages of the growing season.

At a growing degree day of 605, there was a statistically significant difference (p < 0.05) in microbiome compositions between Betula_populifolia and Populus_tremuloides. In contrast, for growing degree days 437, 1606, and 2140, the differences in microbiomes were not statistically significant (p > 0.05). Similarly, for growing degree days 1087, 1992, and 2219, no significant differences in microbiome compositions were observed (p > 0.05).

These findings suggest that while interspecific variation between Betula_populifolia and Populus_tremuloides microbiomes occurs at certain growing degree days, it may not be consistent throughout the growing season. The variation in microbiome compositions could be influenced by factors such as phenological changes, environmental conditions, and interspecific interactions. Further investigations are warranted to explore the underlying mechanisms driving these observed differences and their ecological implications.



################################################################################
## 3. RELATIVE ABUNDANCES???
################################################################################

```{r}
# Select only ASV columns
asv_cols <- grep("^ASV\\d+$", names(asv_scaled_noPlants_Phen_filt_LMM))

# Extract "sample_id", "Species", and "GDD_5C" columns
meta_data_relabund <- asv_scaled_noPlants_Phen_filt_LMM[, c("sample_id", "Plant_ID", "Species", "GDD_5C")]

# Compute total counts for ASVs only
total_counts <- rowSums(asv_scaled_noPlants_Phen_filt_LMM[, asv_cols])

# Calculate relative abundances for ASVs only
relative_abundances <- asv_scaled_noPlants_Phen_filt_LMM[, asv_cols] / total_counts

# Sanity check (all rowSums should equal 1)
rowSums(relative_abundances)

# Normalize relative abundances using TSS
#normalized_abundances <- prop.table(as.matrix(relative_abundances), margin = 2)

# Combine "sample_id", "Species", "GDD_5C" with relative abundances
long_df <- cbind(meta_data_relabund, as.data.frame(relative_abundances))

# Reshape the data
combined_df <- long_df %>%
  gather(key = "ASV", value = "RelativeAbundance", -sample_id, -Plant_ID, -Species, -GDD_5C)

# Run the LMM
lmm_rel_abund_inter1 <- lmer(RelativeAbundance ~ Species + GDD_5C + Species:GDD_5C + (1 | sample_id), data = combined_df)
lmm_rel_abund_inter2 <- lmer(sqrt(RelativeAbundance) ~ Species + GDD_5C + Species:GDD_5C + (1 | sample_id), data = combined_df)
lmm_rel_abund_inter3 <- lmer(I(RelativeAbundance^2) ~ Species + GDD_5C + Species:GDD_5C + (1 | sample_id), data = combined_df)
lmm_rel_abund_inter5 <- lmer(RelativeAbundance ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = combined_df)
lmm_rel_abund_inter6 <- lmer(I(RelativeAbundance^2) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = combined_df)
lmm_rel_abund_inter7 <- lmer(sqrt(RelativeAbundance) ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = combined_df)
#lmm_rel_abund_inter4 <- lmer(I(RelativeAbundance^2) ~ Species + GDD_5C + Species:GDD_5C + (1 | ASV), data = combined_df)

#I have repeated measurements on individuals sampled over time (7 times each) and expect the same ASVs across samples, it seems reasonable to consider a sample-level random effect to account for the repeated measurements on the same individuals. Therefore, using (1 | sample_id) as the random effect could be a suitable choice.

#Probably best NOT to use `ASV` column as random effect b/c `sample_id` represents the repeated measurements taken over time from the same individual plants. Since we have 7 samples per individual plant taken at different time points, using `sample_id` as a random effect allows you to account for the repeated measures within each plant and properly model the within-plant correlation structure (important for `lmm_rel_abund_inter4`)

#This is why we still choose `lmm_rel_abund_inter3`

summary(lmm_rel_abund_inter1)
summary(lmm_rel_abund_inter2)
summary(lmm_rel_abund_inter3)
summary(lmm_rel_abund_inter5)
summary(lmm_rel_abund_inter6)
summary(lmm_rel_abund_inter7)

anova(lmm_rel_abund_inter1, lmm_rel_abund_inter2, lmm_rel_abund_inter3, lmm_rel_abund_inter5, lmm_rel_abund_inter6, lmm_rel_abund_inter7)
```

```{r}
#Subset `relative abundances` or `combined_df`!!!!
rel_abund_437 <- subset(combined_df, GDD_5C == 437)
rel_abund_605 <- subset(combined_df, GDD_5C == 605)
rel_abund_1087 <- subset(combined_df, GDD_5C == 1087)
rel_abund_1606 <- subset(combined_df, GDD_5C == 1606)
rel_abund_1992 <- subset(combined_df, GDD_5C == 1992)
rel_abund_2140 <- subset(combined_df, GDD_5C == 2140)
rel_abund_2219 <- subset(combined_df, GDD_5C == 2219)
```


(a) GDD 437#####################################################################

```{r, eval=FALSE}
shapiro.test(rel_abund_437$RelativeAbundance)

# p = 0.786 > 0.05 --> it is NORMAL, so do ANOVA
```

FOR RELATIVE ABUNDANCE: REFER TO ITUMELENG CONVO RECORDING!!! He said Pairwise Comparisons on specific taxa!!!


```{r}
diagnostic_relabund1 <- plot(check_model(lmm_rel_abund_inter1))

diagnostic_relabund1[[4]]
```

```{r}
check_model(lmm_rel_abund_inter2, check = "normality")
```

```{r}
check_model(lmm_rel_abund_inter3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
#check_model(lmm_rel_abund_inter4)
```

```{r}
check_model(lmm_rel_abund_inter5)
```

```{r}
check_model(lmm_rel_abund_inter6)

plot(lmm_rel_abund_inter3)

qqnorm(residuals(lmm_rel_abund_inter6))
qqline(residuals(lmm_rel_abund_inter6))

hist(residuals(lmm_rel_abund_inter6))
```

```{r}
check_model(lmm_rel_abund_inter7)

#probably choose `lmm_rel_abund_inter3`

#NOTE: Chisq stats not as informative here b/c we're just transforming one variable differently in each model, NOT changing the number of variables in each model.
```


```{r}
#install.packages('TMB', type = 'source')
#library(glmmTMB)
#install.packages("pscl")
#library(pscl)

# Fit a zero-inflated negative binomial model
#zinb_model_relabund <- zeroinfl(RelativeAbundance ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID),
#                                data = combined_df, dist = "negbin")

# View model summary
#summary(zinb_model_relabund)


# Fit a GLM with a Gaussian distribution
#glm_model_relabund <- glm(log(RelativeAbundance) ~ Species + GDD_5C + Species:GDD_5C,
#                 data = combined_df, family = gaussian())

# View model summary
#summary(glm_model_relabund)


#plot(glm_model_relabund)




# Install the package if you haven't already
#install.packages("randomForest")
# Load the package
library(randomForest)

# Assuming 'combined_df' is your data frame
set.seed(123) # For reproducibility
train_index <- sample(1:nrow(combined_df), size = 0.7 * nrow(combined_df))
train_set <- combined_df[train_index, ]
test_set <- combined_df[-train_index, ]

# Fit the Random Forest model with specified predictors
rf_model_relabund <- randomForest(RelativeAbundance ~ Species + GDD_5C + Species:GDD_5C, data = train_set, ntree = 500, mtry = 2)

# View the model summary
print(rf_model_relabund)



```



```{r}
library(phyloseq)
library(lme4)

# Make `phyloseq` object into data.frame
ps_df <- psmelt(ps_phen_asv_LMM)

# Calculate relative abundance for each sample
ps_df <- ps_df %>%
 group_by(Sample) %>%
 mutate(RelativeAbundance = Abundance / sum(Abundance))
```


```{r}
#-------------------------------------------------------------------------
# Homogeneity of Slopes faceted by 'Species'
#-------------------------------------------------------------------------

## NOTE: Homoegenity of slopes is just looking at the data but not the actual
## results, plus there are no error bars, so it's telling if there's
## potentially an interaction, but not definitely whether or not. Do NOT rely
## on this, especially b/c no error bars.

#-------------------------------------------------------------------------
# (a) x=`GDD_5C`
#-------------------------------------------------------------------------
# Untransformed:

levels = c("Betula_populifolia", "Populus_tremuloides")
myplot_relabund <- ggplot(data = combined_df, aes(x = GDD_5C,
    y = RelativeAbundance)) + facet_grid(. ~ Species) + geom_point()
myplot_relabund <- myplot_relabund + stat_smooth(method = lm, se = FALSE) + stat_smooth(se = FALSE,
    color = "red") + labs(y = expression(~RelativeAbundance), x = expression(~GDD_5C))
myplot_relabund
```


```{r}
#-------------------------------------------------------------------------
# Visualize data with a Scatterplot Matrix
#-------------------------------------------------------------------------

# To evaluate not only linearity, but also collinearity; r.e. lecture on
# Multiple Regression (lec. 16/17) slide 46

scatter_plot_relabund <- scatterplotMatrix(~RelativeAbundance + sample_Species + GDD_5C, regLine = TRUE, smooth = TRUE,
    diagonal = TRUE, data = ps_df)
```


```{r}
# Example linear-mixed model
lmm_relabund_inter <- lmer(I(RelativeAbundance^2) ~ sample_Species + GDD_5C + sample_Species:GDD_5C + (1|Plant_ID), data = ps_df)
summary(lmm_relabund_inter)

check_model(lmm_relabund_inter, show_dots = TRUE, line_size = 0.8, check = "pp_check")
```





################################################################################
## SPECIFIC ASVs (FOUND IN DIFFERENTIAL ABUNDANCE ANALYSIS & TAXONOMIC ABUNDANCES)
################################################################################

```{r, eval=FALSE}
# Load required packages
library(lme4)

# Assume your data frame is called 'df' and contains columns for Species, GDD, and ASV counts

# Get the names of ASV count columns from your data frame
asv_columns_relabund <- grep("^ASV", names(asv_scaled_noPlants_Phen_filt_LMM), value = TRUE)

# Add the grouping factor Plant_ID to the data frame explicitly
asv_scaled_noPlants_Phen_filt_LMM$Plant_ID <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$Plant_ID)

# Construct the formula dynamically
formula_relabund <- as.formula(paste("cbind(", paste(asv_columns_relabund, collapse = ", "), ") ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID)"))

# Fit the multivariate LMM
relabund_multivariate_lmm <- lmer(formula_relabund, data = asv_scaled_noPlants_Phen_filt_LMM)

# Inspect the model summary
summary(relabund_multivariate_lmm)
```

**NOTE:** DO NOT do it this way!!! Doing an LMM for each ASV is annoying and too computationally intensive, and not consistent. Instead, since you can only compare the 2 levels of host `Species` in DESeq2, it's MORE APPROPRO to do DESeq2 at each of the 6 `GDD_5C` sampling points, then use the adjusted p-values from DESeq2!!!

**I did this already earlier!!**


```{r}
#asv_rel_abundance <- asv_scaled_noPlants_Phen_filt_LMM
#asv_columns <- grep("^ASV", colnames(asv_rel_abundance))
#total_counts <- rowSums(asv_rel_abundance[, asv_columns])
#asv_rel_abundance[, asv_columns] <- asv_rel_abundance[, asv_columns] / total_counts

## DON'T transform; used raw counts since we're going off of results of DESeq2 (diff abundance analysis)

#ASV10_LMM <- lmer(ASV10 ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_rel_abundance)

#summary(ASV10_LMM)
```


```{r}
#ASV106_LMM <- lmer(ASV106 ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_rel_abundance)
#summary(ASV106_LMM)

#ASV107_LMM <- lmer(ASV107 ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_rel_abundance)
#summary(ASV107_LMM)

#ASV110_LMM <- lmer(ASV110 ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_rel_abundance)
#summary(ASV110_LMM)

#ASV186_LMM <- lmer(ASV186 ~ Species + GDD_5C + Species:GDD_5C + (1 | Plant_ID), data = asv_rel_abundance)
#summary(ASV186_LMM)
```


################################################################################
##                        INTRASPECIFIC STATISTICS
################################################################################



################################################################################
## ALPHA DIVERSITY
################################################################################

################################################################################
## 1. ASV Richness:
################################################################################

```{r}
asv_scaled_noPlants_Phen_filt_LMM$`Collection-Month` <- as.factor(asv_scaled_noPlants_Phen_filt_LMM$`Collection-Month`)
```

### (a) Betula_populifolia:#####################################################

```{r}
# For Betula
lmm_model_betula_specnumber1 <- lmer(specnumber ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber1)
```


```{r}
# For Betula
lmm_model_betula_specnumber2 <- lmer(sqrt(specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber2)
```


```{r}
# For Betula
lmm_model_betula_specnumber3 <- lmer(log(specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber3)
```


```{r}
# For Betula
lmm_model_betula_specnumber4 <- lmer(I(specnumber^2) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber4)
```


```{r}
# For Betula
lmm_model_betula_specnumber5 <- lmer((1/specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber5)
```


```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_betula_specnumber1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber5, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
# NOTE: `lmm_model_betula_specnumber3` is most promising, BUT `Plant_ID` and `GDD_5C:Plant_ID` have high VIFs. So, let's try dropping `Plant_ID` itself. 

lmm_model_betula_specnumber6 <- lmer(log(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber6)
```


```{r}
# Another time by dropping the interaction term

lmm_model_betula_specnumber7 <- lmer(log(specnumber) ~ GDD_5C + Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber7)
```


```{r}
# One more time with ONLY GDD_5C as fixed; `Collection-Month` as random

lmm_model_betula_specnumber8 <- lmer(log(specnumber) ~ GDD_5C + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber8)
```


```{r}
# And one last time with ONLY GDD_5C as fixed; `Plant_ID` as random

lmm_model_betula_specnumber9 <- lmer(log(specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber9)
```


```{r}
# Wait! The 1/x transformation has a very low AIC and BIC; let's try altering it. 

lmm_model_betula_specnumber10 <- lmer((1/specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber10)
```


```{r}
lmm_model_betula_specnumber11 <- lmer((1/specnumber) ~ GDD_5C + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber11)
```


```{r}
lmm_model_betula_specnumber12 <- lmer(specnumber ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber12)
```


```{r}
lmm_model_betula_specnumber13 <- lmer(log(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber13)
```


```{r}
lmm_model_betula_specnumber14 <- lmer((1/specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber14)
```


```{r}
lmm_model_betula_specnumber15 <- lmer(I(specnumber^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber15)
```


```{r}
lmm_model_betula_specnumber16 <- lmer(sqrt(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber16)
```


**NOTE:** The only models with NO singularity issues are:
- `lmm_model_betula_specnumber9`
- `lmm_model_betula_specnumber10`
- `lmm_model_betula_specnumber13`
- `lmm_model_betula_specnumber14`


```{r}
check_model(lmm_model_betula_specnumber6, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber7, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber8, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber9, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```

```{r}
check_model(lmm_model_betula_specnumber10, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```

```{r}
check_model(lmm_model_betula_specnumber11, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```

```{r}
check_model(lmm_model_betula_specnumber12, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber13, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber14, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber15, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_specnumber16, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```

**NOTE:** `lmm_model_betula_specnumber13` & `lmm_model_betula_specnumber14` look best and have no singularity issues...

BUT: If we ALLOW Singularity, we can also say `lmm_model_betula_specnumber6`, `lmm_model_betula_specnumber7`, & `lmm_model_betula_specnumber16` also look good.


```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_betula_specnumber1)) # p=0.3492 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber2)) # p=0.9317 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber3)) # p=0.9008 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber4)) # p=0.001712 -> NOT Normal!
shapiro.test(residuals(lmm_model_betula_specnumber5)) # p=0.2846 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber6)) # p=0.5055 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber7)) # p=0.705 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber8)) # p=0.3381 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber9)) # p=0.4208 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber10)) # p=0.1789 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber11)) # p=0.1735 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber12)) # p=0.1261 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber13)) # p=0.6781 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber14)) # p=0.2961 -> Normal!
shapiro.test(residuals(lmm_model_betula_specnumber15)) # p=0.001568 -> NOT Normal!
shapiro.test(residuals(lmm_model_betula_specnumber16)) # p=0.3932 -> Normal!

# Our likely choices, `lmm_model_betula_specnumber9` or `lmm_model_betula_specnumber10`, adhere to Normality.
```


```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model' with ANOVA model:

anova(lmm_model_betula_specnumber1, lmm_model_betula_specnumber2, lmm_model_betula_specnumber3, lmm_model_betula_specnumber4, lmm_model_betula_specnumber5, lmm_model_betula_specnumber6, lmm_model_betula_specnumber7, lmm_model_betula_specnumber8, lmm_model_betula_specnumber9, lmm_model_betula_specnumber10, lmm_model_betula_specnumber11, lmm_model_betula_specnumber12, lmm_model_betula_specnumber13, lmm_model_betula_specnumber14, lmm_model_betula_specnumber15, lmm_model_betula_specnumber16)

# Best/lowest AIC and BIC values for `lmm_model_betula_specnumber5`, BUT: terrible residuals, collinearity issues, and singularity issues.

#Next Best: `lmm_model_betula_specnumber10` has the next lowest AIC and BIC values (`lmm_model_betula_specnumber11` has low values, BUT a singularity issue, likely because GDD and  Collection-Month have some collinearity due to having temporal characteristics. 

# POSSIBLE/LIKELY CHOICE: `lmm_model_betula_specnumber14` -> LOWEST!
```


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_betula_specnumber1 <- Anova(lmm_model_betula_specnumber1)
anova_lmm_betula_specnumber2 <- Anova(lmm_model_betula_specnumber2)
anova_lmm_betula_specnumber3 <- Anova(lmm_model_betula_specnumber3)
anova_lmm_betula_specnumber4 <- Anova(lmm_model_betula_specnumber4)
anova_lmm_betula_specnumber5 <- Anova(lmm_model_betula_specnumber5)
anova_lmm_betula_specnumber6 <- Anova(lmm_model_betula_specnumber6)
anova_lmm_betula_specnumber7 <- Anova(lmm_model_betula_specnumber7)
anova_lmm_betula_specnumber8 <- Anova(lmm_model_betula_specnumber8)
anova_lmm_betula_specnumber9 <- Anova(lmm_model_betula_specnumber9)
anova_lmm_betula_specnumber10 <- Anova(lmm_model_betula_specnumber10)
anova_lmm_betula_specnumber11 <- Anova(lmm_model_betula_specnumber11)
anova_lmm_betula_specnumber12 <- Anova(lmm_model_betula_specnumber12)
anova_lmm_betula_specnumber13 <- Anova(lmm_model_betula_specnumber13)
anova_lmm_betula_specnumber14 <- Anova(lmm_model_betula_specnumber14)
anova_lmm_betula_specnumber15 <- Anova(lmm_model_betula_specnumber15)
anova_lmm_betula_specnumber16 <- Anova(lmm_model_betula_specnumber16)

summary(anova_lmm_betula_specnumber1)
summary(anova_lmm_betula_specnumber2)
summary(anova_lmm_betula_specnumber3)
summary(anova_lmm_betula_specnumber4)
summary(anova_lmm_betula_specnumber5)
summary(anova_lmm_betula_specnumber6)
summary(anova_lmm_betula_specnumber7)
summary(anova_lmm_betula_specnumber8)
summary(anova_lmm_betula_specnumber9)
summary(anova_lmm_betula_specnumber10)
summary(anova_lmm_betula_specnumber11)
summary(anova_lmm_betula_specnumber12)
summary(anova_lmm_betula_specnumber13)
summary(anova_lmm_betula_specnumber14)
summary(anova_lmm_betula_specnumber15)
summary(anova_lmm_betula_specnumber16)

# We want the HIGHEST ChiSq and LOWEST p-value associated with it. 

# Here, `lmm_model_betula_specnumber14` seems best! 
```


```{r}
################################################################################
#POSSIBLE CHOICE: `lmm_model_betula_specnumber14`
################################################################################

lmm_model_betula_specnumber14 <- lmer((1/specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber14)
```


```{r}
#------------------------------------------------------------------------------------
## Marginal R^2 for `GDD_5C` only
#------------------------------------------------------------------------------------

# Fit the linear mixed-effects model with just `Species`
lmm_model_specnumber_betula_gdd <- lmer(log(specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

# Calculate marginal R-squared for `Species`
specnumber_marginal_r_squared_betula_gdd <- r.squaredGLMM(lmm_model_specnumber_betula_gdd, mu0 = "fixed")
print(specnumber_marginal_r_squared_betula_gdd)
```



```{r}
#------------------------------------------------------------------------------------
## Marginal R^2 for `Plant_ID:GDD_5C` interaction only
#------------------------------------------------------------------------------------

# Fit the linear mixed-effects model with just `Species`
lmm_model_specnumber_betula_interaction <- lmer(log(specnumber) ~ Plant_ID:GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

# Calculate marginal R-squared for `Species`
specnumber_marginal_r_squared_betula_interaction <- r.squaredGLMM(lmm_model_specnumber_betula_interaction, mu0 = "fixed")
print(specnumber_marginal_r_squared_betula_interaction)
```


```{r}
#--------------------------------------------------------------
## Conditional & Marginal R^2 for Model overall!
#--------------------------------------------------------------

# Calculate marginal R-squared for `GDD_5C`
betula_specnumber_r_squared <- r.squaredGLMM(lmm_model_betula_specnumber14, mu0 = "fixed")
print(betula_specnumber_r_squared)
```

**NOTE:** This HIGH R2c (conditional R^2) is a bit suspect, since it's saying over 80% of variance is being explained. This indicates possible overfitting to me, especially due to model complexity. Therefore, our ACTUAL CHOICE will be:

```{r}
################################################################################
#ULTIMATE CHOICE: `lmm_model_betula_specnumber10`
################################################################################

lmm_model_betula_specnumber10 <- lmer((1/specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_specnumber10)
```


```{r}
#--------------------------------------------------------------
## Conditional & Marginal R^2 for Model overall!
#--------------------------------------------------------------

# Calculate marginal R-squared for `GDD_5C`
betula_specnumber_r_squared <- r.squaredGLMM(lmm_model_betula_specnumber10, mu0 = "fixed")
print(betula_specnumber_r_squared)
```


### (b) Populus_tremuloides:####################################################

```{r}
# For Populus
lmm_model_populus_specnumber1 <- lmer(specnumber ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber1)
```


```{r}
# For Populus
lmm_model_populus_specnumber2 <- lmer(sqrt(specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber2)
```


```{r}
# For Populus
lmm_model_populus_specnumber3 <- lmer(log(specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber3)
```


```{r}
# For Populus
lmm_model_populus_specnumber4 <- lmer(I(specnumber^2) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber4)
```


```{r}
# For Populus
lmm_model_populus_specnumber5 <- lmer((1/specnumber) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber5)
```


```{r}
# NOTE: `lmm_model_populus_specnumber3` is most promising, BUT `Plant_ID` and `GDD_5C:Plant_ID` have high VIFs. So, let's try dropping `Plant_ID` itself. 

lmm_model_populus_specnumber6 <- lmer(log(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber6)
```


```{r}
# For Populus

lmm_model_populus_specnumber7 <- lmer(log(specnumber) ~ GDD_5C + Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber7)
```


```{r}
# For Populus

lmm_model_populus_specnumber8 <- lmer(log(specnumber) ~ GDD_5C + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber8)
```


```{r}
# For Populus

lmm_model_populus_specnumber9 <- lmer(log(specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber9)
```


```{r}
# For Populus

lmm_model_populus_specnumber10 <- lmer((1/specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber10)
```


```{r}
lmm_model_populus_specnumber11 <- lmer(specnumber ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber11)
```


```{r}
lmm_model_populus_specnumber12 <- lmer(log(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber12)
```


```{r}
lmm_model_populus_specnumber13 <- lmer((1/specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber13)
```


```{r}
lmm_model_populus_specnumber14 <- lmer(I(specnumber^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber14)
```


```{r}
lmm_model_populus_specnumber15 <- lmer(sqrt(specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber15)
```

**NOTE:** The only models WITHOUT singularity issues are:
- `lmm_model_populus_specnumber9`
- `lmm_model_populus_specnumber10`


```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_populus_specnumber1)) # p=0.3458 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber2)) # p=0.664 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber3)) # p=0.4467 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber4)) # p=0.008562 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber5)) # p=0.01309 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber6)) # p=0.6092 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber7)) # p=0.5035 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber8)) # p=0.9392 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber9)) # p=0.8613 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber10)) # p=0.00296 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber11)) # p=0.02229 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber12)) # p=0.6092 -> Normal!
shapiro.test(residuals(lmm_model_populus_specnumber13)) # p=0.0435 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber14)) # p=0.0.0001654 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_specnumber15)) # p=0.2567 -> NOT Normal!
```


```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_populus_specnumber1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber5, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber6, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber7, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber8, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber9, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber10, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber11, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber12, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber13, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber14, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_specnumber15, check = c("normality", "vif", "linearity", "homogeneity", "outliers"))
```

**NOTE:** Hard to determine from diagnostics above alone...

IF NO SINGULARITY: `lmm_model_populus_specnumber9` looks best...

IF SINGULARITY ALLOWED: Can consider `lmm_model_populus_specnumber6`, `lmm_model_populus_specnumber8`, `lmm_model_populus_specnumber12`, `lmm_model_populus_specnumber13` & `lmm_model_populus_specnumber15`



```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model' with ANOVA model:

anova(lmm_model_populus_specnumber1, lmm_model_populus_specnumber2, lmm_model_populus_specnumber3, lmm_model_populus_specnumber4, lmm_model_populus_specnumber5, lmm_model_populus_specnumber6, lmm_model_populus_specnumber7, lmm_model_populus_specnumber8, lmm_model_populus_specnumber9, lmm_model_populus_specnumber10, lmm_model_populus_specnumber11, lmm_model_populus_specnumber12, lmm_model_populus_specnumber13, lmm_model_populus_specnumber14, lmm_model_populus_specnumber15)

## OVERALL: `lmm_model_populus_specnumber8` and `lmm_model_populus_specnumber9` practically have identical values, but they are both the best!

# NOTE: Even though `lmm_model_populus_specnumber13` has lowest AIC an BIC, there is a SINGULARITY issues!
# NOTE: `lmm_model_populus_specnumber10` has the next lowest AIC an BIC, so it's our likely choice (despite lacking normality, ut important to acknowledge that biological data doesn't always conform to normality).

# IF SINGULARITY ALLOWED: `lmm_model_populus_specnumber13` is VERY good!
# BUT: Also consider if singularity allowed: `lmm_model_populus_specnumber6`, `lmm_model_populus_specnumber8`, or `lmm_model_populus_specnumber12` (6 & 12 have identical values)
```


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_populus_specnumber1 <- Anova(lmm_model_populus_specnumber1)
anova_lmm_populus_specnumber2 <- Anova(lmm_model_populus_specnumber2)
anova_lmm_populus_specnumber3 <- Anova(lmm_model_populus_specnumber3)
anova_lmm_populus_specnumber4 <- Anova(lmm_model_populus_specnumber4)
anova_lmm_populus_specnumber5 <- Anova(lmm_model_populus_specnumber5)
anova_lmm_populus_specnumber6 <- Anova(lmm_model_populus_specnumber6)
anova_lmm_populus_specnumber7 <- Anova(lmm_model_populus_specnumber7)
anova_lmm_populus_specnumber8 <- Anova(lmm_model_populus_specnumber8)
anova_lmm_populus_specnumber9 <- Anova(lmm_model_populus_specnumber9)
anova_lmm_populus_specnumber10 <- Anova(lmm_model_populus_specnumber10)
anova_lmm_populus_specnumber11 <- Anova(lmm_model_populus_specnumber11)
anova_lmm_populus_specnumber12 <- Anova(lmm_model_populus_specnumber12)
anova_lmm_populus_specnumber13 <- Anova(lmm_model_populus_specnumber13)
anova_lmm_populus_specnumber14 <- Anova(lmm_model_populus_specnumber14)
anova_lmm_populus_specnumber15 <- Anova(lmm_model_populus_specnumber15)

summary(anova_lmm_populus_specnumber1)
summary(anova_lmm_populus_specnumber2)
summary(anova_lmm_populus_specnumber3)
summary(anova_lmm_populus_specnumber4)
summary(anova_lmm_populus_specnumber5)
summary(anova_lmm_populus_specnumber6)
summary(anova_lmm_populus_specnumber7)
summary(anova_lmm_populus_specnumber8)
summary(anova_lmm_populus_specnumber9)
summary(anova_lmm_populus_specnumber10)
summary(anova_lmm_populus_specnumber11)
summary(anova_lmm_populus_specnumber12)
summary(anova_lmm_populus_specnumber13)
summary(anova_lmm_populus_specnumber14)
summary(anova_lmm_populus_specnumber15)

#`lmm_model_populus_specnumber13` mostly, then `lmm_model_populus_specnumber6` and `lmm_model_populus_specnumber12` have singularity issues!
```


```{r}
################################################################################
#CHOICE:`lmm_model_populus_specnumber10`
################################################################################

lmm_model_populus_specnumber10 <- lmer((1/specnumber) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber10)


################################################################################
## IF SINGULARITIES ALLOWED; ALTERNATE CHOICE: `lmm_model_populus_specnumber13`
################################################################################

lmm_model_populus_specnumber13 <- lmer((1/specnumber) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_specnumber13)

## NOTE: This is why we likely DON'T choose the one with SINGULARITY... Notice that here, the R^2 for the Random Effect is 0, so NO VARIANCE in our Random Effect (corroborated by our ChiSq values and >Pr(ChiSq) being oddly all similar, and our R2c and R2m being the same too...):

library(rsq)

rsq.lmm(lmm_model_populus_specnumber13)

#$model
#[1] 0.314838

#$fixed
#[1] 0.314838

#$random -> NOTE NO VARIANCE!
#[1] 0 
```


```{r}
#--------------------------------------------------------------
## Conditional & Marginal R^2 for `GDD_5C` in Populus
#--------------------------------------------------------------

# Calculate marginal R-squared for `GDD_5C`
populus_specnumber_r_squared <- r.squaredGLMM(lmm_model_populus_specnumber9, mu0 = "fixed")
print(populus_specnumber_r_squared)

populus_specnumber_r_squared <- r.squaredGLMM(lmm_model_populus_specnumber10, mu0 = "fixed")
print(populus_specnumber_r_squared)

#OR

# Calculate marginal R-squared for `GDD_5C`
populus_specnumber_r_squared <- r.squaredGLMM(lmm_model_populus_specnumber13, mu0 = "fixed")
print(populus_specnumber_r_squared)

# *NOTE: Will have to do marginal/conditional R^2 for GDD_5C:Plant_ID too!!!
# *NOTE: Odd to have both conditional and marginal R^2 be same... 
```



################################################################################
## 3. Shannon Diversity:
################################################################################


### (a) Betula_populifolia:#####################################################

```{r}
# For Betula
lmm_model_betula_shannon1 <- lmer(alphaDiv ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon1)
```


```{r}
# For Betula
lmm_model_betula_shannon2 <- lmer(sqrt(alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon2)
```


```{r}
# For Betula
lmm_model_betula_shannon3 <- lmer(I(alphaDiv^2) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon3)
```


```{r}
# For Betula
lmm_model_betula_shannon4 <- lmer(log(alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon4)
```


```{r}
# For Betula
lmm_model_betula_shannon5 <- lmer((1/alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon5)
```


```{r}
# For Betula
lmm_model_betula_shannon6 <- lmer(I(alphaDiv^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon6)
```


```{r}
# For Betula
lmm_model_betula_shannon7 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon7)
```


```{r}
# For Betula
lmm_model_betula_shannon8 <- lmer(alphaDiv ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon8)
```


```{r}
# For Betula
lmm_model_betula_shannon9 <- lmer(I(alphaDiv^2) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon9)
```


```{r}
# For Betula
lmm_model_betula_shannon10 <- lmer(sqrt(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon10)
```


```{r}
# For Betula
lmm_model_betula_shannon11 <- lmer((1/alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon11)
```


```{r}
# For Betula
lmm_model_betula_shannon12 <- lmer(log(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon12)
```


```{r}
# For Populus
lmm_model_betula_shannon13 <- lmer(alphaDiv ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon13)
```


```{r}
# For Populus
lmm_model_betula_shannon14 <- lmer(log(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon14)
```


```{r}
# For Populus
lmm_model_betula_shannon15 <- lmer((1/alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon15)
```


```{r}
# For Populus
lmm_model_betula_shannon16 <- lmer(I(alphaDiv^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon16)
```


```{r}
# For Populus
lmm_model_betula_shannon17 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon17)
```

**NOTE:** The only models WITHOUT Singularity issues are:
- `lmm_model_betula_shannon8`
- `lmm_model_betula_shannon9`
- `lmm_model_betula_shannon10`
- `lmm_model_betula_shannon11`
- `lmm_model_betula_shannon12`



```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_betula_shannon1)) # p=0.5433 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon2)) # p=0.2564 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon3)) # p=0.8828 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon4)) # p=0.09625-> Normal!
shapiro.test(residuals(lmm_model_betula_shannon5)) # p=0.0109 -> NOT Normal!
shapiro.test(residuals(lmm_model_betula_shannon6)) # p=0.9165 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon7)) # p=0.1556 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon8)) # p=0.8539 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon9)) # p=0.8019 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon10)) # p=0.3257 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon11)) # p=0.0001553 -> NOT Normal!
shapiro.test(residuals(lmm_model_betula_shannon12)) # p=0.04153 -> Not QUIT Normal/Approx. Normal?!
shapiro.test(residuals(lmm_model_betula_shannon13)) # p=0.5258 -> Normal
shapiro.test(residuals(lmm_model_betula_shannon14)) # p=0.04229 -> Not QUIT Normal/Approx. Normal?!
shapiro.test(residuals(lmm_model_betula_shannon15)) # p=0.00228 -> NOT Normal!
shapiro.test(residuals(lmm_model_betula_shannon16)) # p=0.9321 -> Normal!
shapiro.test(residuals(lmm_model_betula_shannon17)) # p=0.1546 -> Normal!
```


```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_betula_shannon1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon5, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon6, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon7, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon8, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon9, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon10, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon11, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon12, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon13, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon14, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon15, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon16, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_betula_shannon17, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```




**NOTE:** `lmm_model_betula_shannon7`, `lmm_model_betula_shannon13`, `lmm_model_betula_shannon14`, and `lmm_model_betula_shannon17` all seem to have the best diagnostics above... 
BUT: Worried that they have a SINGULARITY issue!

SO: Next best is between `lmm_model_betula_shannon8`, `lmm_model_betula_shannon10`, and `lmm_model_betula_shannon12` -> all relatively similar... 

IF: Singularity is not an issue, I would choose `lmm_model_betula_shannon17` !


```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model' with ANCOVA model:

anova(lmm_model_betula_shannon1, lmm_model_betula_shannon2, lmm_model_betula_shannon3, lmm_model_betula_shannon4, lmm_model_betula_shannon5, lmm_model_betula_shannon6, lmm_model_betula_shannon7, lmm_model_betula_shannon8, lmm_model_betula_shannon9, lmm_model_betula_shannon10, lmm_model_betula_shannon11, lmm_model_betula_shannon12, lmm_model_betula_shannon13, lmm_model_betula_shannon14, lmm_model_betula_shannon15, lmm_model_betula_shannon16, lmm_model_betula_shannon17)

## Best is `lmm_model_betula_shannon11`, BUT: Posterior Predictive Check & Influential Observations/Outliers is worse than `lmm_model_betula_shannon10`, but has better Homogeneity of Variance and Linearity. 

## Next Best: `lmm_model_betula_shannon15` -> BUT: worried about Singularity issue AND terrible diagnostic stats with check_model()

## Next Best: `lmm_model_betula_shannon5` has best stats here, BUT: Has collinearity AND singularity issues

## NEXT BEST/LIKELY CHOICE: `lmm_model_betula_shannon10` or `lmm_model_betula_shannon11`

## NOTE: Even though `lmm_model_betula_shannon11` isn't normally distributed, keep in mind that this is often the case with biological data.

###############################################################
## IF SINGULARITY ALLOWED: `lmm_model_betula_shannon17`
```


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_betula_shannon1 <- Anova(lmm_model_betula_shannon1)
anova_lmm_betula_shannon2 <- Anova(lmm_model_betula_shannon2)
anova_lmm_betula_shannon3 <- Anova(lmm_model_betula_shannon3)
anova_lmm_betula_shannon4 <- Anova(lmm_model_betula_shannon4)
anova_lmm_betula_shannon5 <- Anova(lmm_model_betula_shannon5)
anova_lmm_betula_shannon6 <- Anova(lmm_model_betula_shannon6)
anova_lmm_betula_shannon7 <- Anova(lmm_model_betula_shannon7)
anova_lmm_betula_shannon8 <- Anova(lmm_model_betula_shannon8)
anova_lmm_betula_shannon9 <- Anova(lmm_model_betula_shannon9)
anova_lmm_betula_shannon10 <- Anova(lmm_model_betula_shannon10)
anova_lmm_betula_shannon11 <- Anova(lmm_model_betula_shannon11)
anova_lmm_betula_shannon12 <- Anova(lmm_model_betula_shannon12)
anova_lmm_betula_shannon13 <- Anova(lmm_model_betula_shannon13)
anova_lmm_betula_shannon14 <- Anova(lmm_model_betula_shannon14)
anova_lmm_betula_shannon15 <- Anova(lmm_model_betula_shannon15)
anova_lmm_betula_shannon16 <- Anova(lmm_model_betula_shannon16)
anova_lmm_betula_shannon17 <- Anova(lmm_model_betula_shannon17)

summary(anova_lmm_betula_shannon1)
summary(anova_lmm_betula_shannon2)
summary(anova_lmm_betula_shannon3)
summary(anova_lmm_betula_shannon4)
summary(anova_lmm_betula_shannon5)
summary(anova_lmm_betula_shannon6)
summary(anova_lmm_betula_shannon7)
summary(anova_lmm_betula_shannon8)
summary(anova_lmm_betula_shannon9)
summary(anova_lmm_betula_shannon10)
summary(anova_lmm_betula_shannon11)
summary(anova_lmm_betula_shannon12)
summary(anova_lmm_betula_shannon13)
summary(anova_lmm_betula_shannon14)
summary(anova_lmm_betula_shannon15)
summary(anova_lmm_betula_shannon16)
summary(anova_lmm_betula_shannon17)

#Supports `anova_lmm_betula_shannon17` (but has singularity issue) and `anova_lmm_betula_shannon7` (but has BOTH singularity AND collinearity issues)
```


```{r}
################################################################################
## CHOICE: `lmm_model_betula_shannon10` (sqrt transformed; GDD as fixed; Plant_ID as random)
################################################################################

lmm_model_betula_shannon10 <- lmer(sqrt(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon10)

#############################
## OR?:

lmm_model_betula_shannon11 <- lmer((1/alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon11)


### THIS WILL BE OUR CHOICE^


################################################################################
## IF SINGULARITY ALLOWED, MAYBEEEE CHOOSE: `lmm_model_betula_shannon17`....
################################################################################

lmm_model_betula_shannon17 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Betula_populifolia"))

summary(lmm_model_betula_shannon17)

## NOTE: This is why we ikely DON'T choose the one with SINGULARITY... Notice that here, the R^2 for the Random Effect is 0, so NO VARIANCE in our Random Effect (corroborated by our ChiSq values and >Pr(ChiSq) being oddly all similar, and our R2c and R2m being the same too...):

library(rsq)

rsq.lmm(lmm_model_betula_shannon17)

#$model
#[1] 0.1981237

#$fixed
#[1] 0.1981237

#$random _> NOTE NO VARIANCE!
#[1] 0 
```



```{r}
#--------------------------------------------------------------
## Conditional & Marginal R^2 for `GDD_5C` in Betula
#--------------------------------------------------------------

# Calculate marginal R-squared for `GDD_5C`
betula_shannon_r_squared <- r.squaredGLMM(lmm_model_betula_shannon10, mu0 = "fixed")
print(betula_shannon_r_squared)

##OR?:

betula_shannon_r_squared <- r.squaredGLMM(lmm_model_betula_shannon11, mu0 = "fixed")
print(betula_shannon_r_squared)

rsq.lmm(lmm_model_betula_shannon10)
rsq.lmm(lmm_model_betula_shannon11)

## Better R^2 values for `lmm_model_betula_shannon11`

# *NOTE: Will have to do marginal/conditional R^2 for GDD_5C:Plant_ID too!!!
# *NOTE: Odd to have both marginal & conditional R^2 be same... ?
```



### (b) Populus_tremuloides:####################################################


```{r}
# For Populus
lmm_model_populus_shannon1 <- lmer(alphaDiv ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon1)
```


```{r}
# For Populus
lmm_model_populus_shannon2 <- lmer(sqrt(alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon2)
```


```{r}
# For Populus
lmm_model_populus_shannon3 <- lmer(log(alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon3)
```


```{r}
# For Populus
lmm_model_populus_shannon4 <- lmer(I(alphaDiv^2) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon4)
```


```{r}
# For Populus
lmm_model_populus_shannon5 <- lmer((1/alphaDiv) ~ GDD_5C + Plant_ID + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon5)
```


```{r}
# For Populus
lmm_model_populus_shannon6 <- lmer(alphaDiv ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon6)
```


```{r}
# For Populus
lmm_model_populus_shannon7 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon7)
```


```{r}
# For Populus
lmm_model_populus_shannon8 <- lmer(log(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon8)
```


```{r}
# For Populus
lmm_model_populus_shannon9 <- lmer(I(alphaDiv^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon9)
```


```{r}
# For Populus
lmm_model_populus_shannon10 <- lmer((1/alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | `Collection-Month`), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon10)
```


```{r}
# For Populus
lmm_model_populus_shannon11 <- lmer(alphaDiv ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon11)
```


```{r}
# For Populus
lmm_model_populus_shannon12 <- lmer(log(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon12)
```


```{r}
# For Populus
lmm_model_populus_shannon13 <- lmer((1/alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon13)
```


```{r}
# For Populus
lmm_model_populus_shannon14 <- lmer(I(alphaDiv^2) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon14)
```


```{r}
# For Populus
lmm_model_populus_shannon15 <- lmer(sqrt(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon15)
```


```{r}
# For Populus
lmm_model_populus_shannon16 <- lmer(alphaDiv ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon16)
```


```{r}
# For Populus
lmm_model_populus_shannon17 <- lmer(log(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon17)
```


```{r}
# For Populus
lmm_model_populus_shannon18 <- lmer((1/alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon18)
```


```{r}
# For Populus
lmm_model_populus_shannon19 <- lmer(I(alphaDiv^2) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon19)
```


```{r}
# For Populus
lmm_model_populus_shannon20 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon20)
```

**NOTE:** Models WITHOUT Singularity issues:
- `lmm_model_populus_shannon1`
- `lmm_model_populus_shannon2`
- `lmm_model_populus_shannon3`
- `lmm_model_populus_shannon5`
- `lmm_model_populus_shannon6`
- `lmm_model_populus_shannon7`
- `lmm_model_populus_shannon8`
- `lmm_model_populus_shannon9`
- `lmm_model_populus_shannon10`
- `lmm_model_populus_shannon11`
- `lmm_model_populus_shannon12`
- `lmm_model_populus_shannon13`
- `lmm_model_populus_shannon14`
- `lmm_model_populus_shannon15`



```{r}
#-------------------------------------------------------------------------
## To be sure of my model, let's run formal diagnostics:
#-------------------------------------------------------------------------
# Formal Test of Normality (Shapiro-Wilks)
#-------------------------------------------------------------------------

shapiro.test(residuals(lmm_model_populus_shannon1)) # p=0.0.0006544 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon2)) # p=5.856e-06 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon3)) # p=6.719e-08 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon4)) # p=0.364-> Normal!
shapiro.test(residuals(lmm_model_populus_shannon5)) # p=3.736e-10 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon6)) # p=0.001089 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon7)) # p=7.289e-06 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon8)) # p=6.75e-08 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon9)) # p=0.498 -> Normal!
shapiro.test(residuals(lmm_model_populus_shannon10)) # p=3.02e-10 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon11)) # p=4.069e-05 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon12)) # p=1.273e-09 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon13)) # p=4.58e-12 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon14)) # p=0.198 -> Normal!
shapiro.test(residuals(lmm_model_populus_shannon15)) # p=1.697e-07 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon16)) # p=0.001085 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon17)) # p=6.729e-08 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon18)) # p=3.019e-10 -> NOT Normal!
shapiro.test(residuals(lmm_model_populus_shannon19)) # p=0.4981 -> Normal!
shapiro.test(residuals(lmm_model_populus_shannon20)) # p=7.258e-06 -> NOT Normal!
```


```{r}
#-------------------------------------------------------------------------
## Check Diagnostic Statistics/Assumptions
#-------------------------------------------------------------------------
check_model(lmm_model_populus_shannon1, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon2, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon3, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon4, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon5, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon6, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon7, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon8, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon9, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon10, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon11, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon12, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon13, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon14, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon15, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon16, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon17, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon18, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon19, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```


```{r}
check_model(lmm_model_populus_shannon20, check = c("pp_check", "normality", "vif", "linearity", "homogeneity", "outliers"))
```

**NOTE:** Maybe `lmm_model_populus_shannon6`, `lmm_model_populus_shannon11`, or `lmm_model_populus_shannon15`...

BUT IF SINGULARITY ALLOWED: Also consider `lmm_model_populus_shannon16`, & `lmm_model_populus_shannon20`

...but hard to tell from check_model()...


```{r}
#-------------------------------------------------------------------------
## Compare Model Fits with anova():
#-------------------------------------------------------------------------

# Compare 'model' with ANOVA model:

anova(lmm_model_populus_shannon1, lmm_model_populus_shannon2, lmm_model_populus_shannon3, lmm_model_populus_shannon4, lmm_model_populus_shannon5, lmm_model_populus_shannon6, lmm_model_populus_shannon7, lmm_model_populus_shannon8, lmm_model_populus_shannon9, lmm_model_populus_shannon10, lmm_model_populus_shannon11, lmm_model_populus_shannon12, lmm_model_populus_shannon13, lmm_model_populus_shannon14, lmm_model_populus_shannon15, lmm_model_populus_shannon16, lmm_model_populus_shannon17, lmm_model_populus_shannon18, lmm_model_populus_shannon19, lmm_model_populus_shannon20)

## BEST: b/w `lmm_model_populus_shannon7`, `lmm_model_populus_shannon15`, & `lmm_model_populus_shannon20`... 
```


```{r}
# ANOVA of LMM model using `car` package.
library(car)
anova_lmm_populus_shannon1 <- Anova(lmm_model_populus_shannon1)
anova_lmm_populus_shannon2 <- Anova(lmm_model_populus_shannon2)
anova_lmm_populus_shannon3 <- Anova(lmm_model_populus_shannon3)
anova_lmm_populus_shannon4 <- Anova(lmm_model_populus_shannon4)
anova_lmm_populus_shannon5 <- Anova(lmm_model_populus_shannon5)
anova_lmm_populus_shannon6 <- Anova(lmm_model_populus_shannon6)
anova_lmm_populus_shannon7 <- Anova(lmm_model_populus_shannon7)
anova_lmm_populus_shannon8 <- Anova(lmm_model_populus_shannon8)
anova_lmm_populus_shannon9 <- Anova(lmm_model_populus_shannon9)
anova_lmm_populus_shannon10 <- Anova(lmm_model_populus_shannon10)
anova_lmm_populus_shannon11 <- Anova(lmm_model_populus_shannon11)
anova_lmm_populus_shannon12 <- Anova(lmm_model_populus_shannon12)
anova_lmm_populus_shannon13 <- Anova(lmm_model_populus_shannon13)
anova_lmm_populus_shannon14 <- Anova(lmm_model_populus_shannon14)
anova_lmm_populus_shannon15 <- Anova(lmm_model_populus_shannon15)
anova_lmm_populus_shannon16 <- Anova(lmm_model_populus_shannon16)
anova_lmm_populus_shannon17 <- Anova(lmm_model_populus_shannon17)
anova_lmm_populus_shannon18 <- Anova(lmm_model_populus_shannon18)
anova_lmm_populus_shannon19 <- Anova(lmm_model_populus_shannon19)
anova_lmm_populus_shannon20 <- Anova(lmm_model_populus_shannon20)

summary(anova_lmm_populus_shannon1)
summary(anova_lmm_populus_shannon2)
summary(anova_lmm_populus_shannon3)
summary(anova_lmm_populus_shannon4)
summary(anova_lmm_populus_shannon5)
summary(anova_lmm_populus_shannon6)
summary(anova_lmm_populus_shannon7)
summary(anova_lmm_populus_shannon8)
summary(anova_lmm_populus_shannon9)
summary(anova_lmm_populus_shannon10)
summary(anova_lmm_populus_shannon11)
summary(anova_lmm_populus_shannon12)
summary(anova_lmm_populus_shannon13)
summary(anova_lmm_populus_shannon14)
summary(anova_lmm_populus_shannon15)
summary(anova_lmm_populus_shannon16)
summary(anova_lmm_populus_shannon17)
summary(anova_lmm_populus_shannon18)
summary(anova_lmm_populus_shannon19)
summary(anova_lmm_populus_shannon20)

## Hard to choose based on this, but best seems to be `lmm_model_populus_shannon7`...

## NOTE: `lmm_model_populus_shannon7` also has NO singularity issues & relatively similar diagnostics to `lmm_model_populus_shannon15` & `lmm_model_populus_shannon20` (and `lmm_model_populus_shannon20` does have singularity issue).

##Followed closely by: `lmm_model_populus_shannon6`, `lmm_model_populus_shannon8`, `lmm_model_populus_shannon16`, & `lmm_model_populus_shannon20`
```


```{r}
################################################################################
## CHOICE: `lmm_model_populus_shannon15` (AIC and BIC blow the others out, on top of everything else)
################################################################################

lmm_model_populus_shannon15 <- lmer(sqrt(alphaDiv) ~ GDD_5C + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon15)

################################################################################
## BUT IF SINGULARITIES ALLOWED: Maybe... `lmm_model_populus_shannon20`
################################################################################

lmm_model_populus_shannon20 <- lmer(sqrt(alphaDiv) ~ GDD_5C + GDD_5C:Plant_ID + (1 | Plant_ID), data = subset(asv_scaled_noPlants_Phen_filt_LMM, Species == "Populus_tremuloides"))

summary(lmm_model_populus_shannon20)


## NOTE: This is why we likely DON'T choose the one with SINGULARITY... Notice that here, the R^2 for the Random Effect is 0, so NO VARIANCE in our Random Effect (corroborated by our ChiSq values and >Pr(ChiSq) being oddly all similar, and our R2c and R2m being the same too...):

library(rsq)

rsq.lmm(lmm_model_populus_shannon20)

#$model
#[1] 0.1982342

#$fixed
#[1] 0.1982342

#$random -> NOTE NO VARIANCE!
#[1] 0
```



```{r}
#--------------------------------------------------------------
## Conditional & Marginal R^2 for Model
#--------------------------------------------------------------

# Calculate marginal R-squared for `GDD_5C`
populus_shannon_r_squared <- r.squaredGLMM(lmm_model_populus_shannon15, mu0 = "fixed")
print(populus_shannon_r_squared)
```


################################################################################
################################################################################
## BETA DIVERSITY (INTRAspecific)
################################################################################


################################################################################
## BETULA - Beta Diversity
################################################################################

### Betula Multivariate Dispersion:

For GDD_5C:


```{r}
# Filter data for Betula_populifolia
betula_data <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Betula_populifolia", ]

gdd_betula <- betula_data$GDD_5C
alphaDiv_betula <- betula_data$alphaDiv
plantid_betula <- betula_data$Plant_ID
```


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)

phen.disper.betula.gdd= betadisper(dist.mat_betula, betula_data$GDD_5C, type = "centroid")

phen.disper.betula.gdd
summary(phen.disper.betula.gdd)
```


```{r}
permutest(phen.disper.betula.gdd, permutations = 999)
```


```{r}
anova(phen.disper.betula.gdd)
```


```{r}
plot(phen.disper.betula.gdd)
```


```{r}
boxplot(phen.disper.betula.gdd, xlab= "Growing Degree Days (5\u00B0C")
```


```{r}
TukeyHSD(phen.disper.betula.gdd) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.betula.gdd))
```



### For Plant_ID (Betula still):


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)
phen.disper.betula.plantid= betadisper(dist.mat_betula, betula_data$Plant_ID, type = "centroid")

phen.disper.betula.plantid
summary(phen.disper.betula.plantid)

#NOTE: The betadisper function calculates the multivariate dispersion (variability) within each group of the categorical variable (Plant_ID).
```


```{r}
permutest(phen.disper.betula.plantid, permutations = 999)

#NOTE:The permutest function performs a permutation test to assess the significance of the F-statistic from the betadisper analysis. The results include the number of permutations (N.Perm) performed and the p-value (Pr(>F)) associated with the permutation test. In this case, the p-value is 0.5, indicating that the F-value is not significant.
```


```{r}
anova(phen.disper.betula.plantid)

#The anova function provides an ANOVA-like analysis of the dispersion values among the groups.
#Groups F: The F-statistic for testing the null hypothesis of equal dispersion among the groups. The F-value is 0.848.
#Groups Pr(>F): The p-value associated with the F-statistic. In this case, the p-value is 0.5061, indicating that the differences in dispersion among groups are not statistically significant.
```


```{r}
plot(phen.disper.betula.plantid)
```


```{r}
boxplot(phen.disper.betula.plantid, xlab= "Plant ID")
```


```{r}
TukeyHSD(phen.disper.betula.plantid) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.betula.plantid))
```


```{r}
#Influence taxonomic composition on betadiveristy by GDDs

phen.betula.gdd.adonis2<- adonis2(dist.mat_betula ~ betula_data$GDD_5C, perm = 999) #Calculate influence of treatment using community  matrix

phen.betula.gdd.adonis2
```


```{r}
#Influence taxonomic composition on betadiveristy by Plant_ID

phen.betula.plantid.adonis2<- adonis2(dist.mat_betula ~ betula_data$Plant_ID, perm = 999) #Calculate influence of treatment using community  matrix

phen.betula.plantid.adonis2
```



## COMBINE RESULTS FOR BOTH GDDs AND SPECIES:


```{r}
#1. Multidispersion Analysis for Interaction (Species & GDDs):

# Calculate multidispersion considering interaction
phen.disper.betula.interact <- betadisper(dist.mat_betula, 
                                   interaction(betula_data$GDD_5C, 
                                               betula_data$Plant_ID),
                                   type = "centroid")

#2. Permutation Test for Interaction:
permutest(phen.disper.betula.interact, permutations = 999)
```


```{r}
#3. ANOVA-Like Analysis for Interaction:
anova(phen.disper.betula.interact)
```


```{r}
plot(phen.disper.betula.interact)
```


```{r}
#Post-hoc Pairwise Comparisons for Interaction

pairwise_dispersion_betula_interact <- TukeyHSD(phen.disper.betula.interact)

head(pairwise_dispersion_betula_interact)
```


### Betula_populifolia PERMANOVA:

Question: Do growing degree days significantly influence the community composition (beta diversity) within Betula?

```{r}
# Filter data for Betula_populifolia
betula_data <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Betula_populifolia", ]

# Perform PERMANOVA for Betula_populifolia
permanova_betula_beta <- adonis2(dist.mat_betula ~ GDD_5C * Plant_ID, data = betula_data, permutations = 999)

# Print PERMANOVA results for Betula_populifolia
print(permanova_betula_beta)
```


### Betula Follow-Up Pairwise PERMANOVA:


```{r}

#NOTE: I can't seem to get pairwise PERMANOVAs to work... 

#Current Error:

#Error in qr.fitted(qrhs, G) : 
#  'qr' and 'y' must have the same number of rows

library(vegan)
library(pairwiseAdonis)
library(dplyr)

#pairwise permanova
pairwise_perm_betula_beta <- pairwise.adonis2(dist.mat_betula ~ GDD_5C * Plant_ID, 
                                    data = betula_data, permutations = 999)

pairwise_perm_betula_beta
```

################################################################################
## POPULUS - Beta Diversity
################################################################################

### Populus Multivariate Dispersion:

For GDD_5C:


```{r}
# Filter data for Populus_tremuloides
populus_data <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Populus_tremuloides", ]
```


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)

phen.disper.populus.gdd= betadisper(dist.mat_populus, populus_data$GDD_5C, type = "centroid")

phen.disper.populus.gdd
summary(phen.disper.populus.gdd)
```


```{r}
permutest(phen.disper.populus.gdd, permutations = 999)
```


```{r}
anova(phen.disper.populus.gdd)
```


```{r}
plot(phen.disper.populus.gdd)
```


```{r}
boxplot(phen.disper.populus.gdd, xlab= "Growing Degree Days (5\u00B0C")
```


```{r}
TukeyHSD(phen.disper.populus.gdd) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.populus.gdd))
```



### For Plant_ID (Populus still):


```{r}
#Calculate the multidispersion within data (Calculating significance of `Species`)
phen.disper.populus.plantid= betadisper(dist.mat_populus, populus_data$Plant_ID, type = "centroid")

phen.disper.populus.plantid
summary(phen.disper.populus.plantid)

#NOTE: The betadisper function calculates the multivariate dispersion (variability) within each group of the categorical variable (Plant_ID).
```


```{r}
permutest(phen.disper.populus.plantid, permutations = 999)

#NOTE:The permutest function performs a permutation test to assess the significance of the F-statistic from the betadisper analysis. The results include the number of permutations (N.Perm) performed and the p-value (Pr(>F)) associated with the permutation test. In this case, the p-value is 0.691, indicating that the F-value is not significant.
```


```{r}
anova(phen.disper.populus.plantid)

#The anova function provides an ANOVA-like analysis of the dispersion values among the groups.
#Groups F: The F-statistic for testing the null hypothesis of equal dispersion among the groups. The F-value is 0.5815.
#Groups Pr(>F): The p-value associated with the F-statistic. In this case, the p-value is 0.6783, indicating that the differences in dispersion among groups are not statistically significant.
```


```{r}
plot(phen.disper.populus.plantid)
```


```{r}
boxplot(phen.disper.populus.plantid, xlab= "Plant ID")
```


```{r}
TukeyHSD(phen.disper.populus.plantid) #Calculate pairwise difference
```


```{r}
plot(TukeyHSD(phen.disper.populus.plantid))
```


```{r}
#Influence taxonomic composition on betadiveristy by GDDs

phen.populus.gdd.adonis2<- adonis2(dist.mat_populus ~ populus_data$GDD_5C, perm = 999) #Calculate influence of treatment using community  matrix

phen.populus.gdd.adonis2
```


```{r}
#Influence taxonomic composition on betadiveristy by Plant_ID

phen.populus.plantid.adonis2<- adonis2(dist.mat_populus ~ populus_data$Plant_ID, perm = 999) #Calculate influence of treatment using community  matrix

phen.populus.plantid.adonis2
```



## COMBINE RESULTS FOR BOTH GDDs AND SPECIES:


```{r}
#1. Multidispersion Analysis for Interaction (Species & GDDs):

# Calculate multidispersion considering interaction
phen.disper.populus.interact <- betadisper(dist.mat_populus, 
                                   interaction(populus_data$GDD_5C, 
                                               populus_data$Plant_ID),
                                   type = "centroid")

#2. Permutation Test for Interaction:
permutest(phen.disper.populus.interact, permutations = 999)
```


```{r}
#3. ANOVA-Like Analysis for Interaction:
anova(phen.disper.populus.interact)
```


```{r}
plot(phen.disper.populus.interact)
```


```{r}
#Post-hoc Pairwise Comparisons for Interaction

pairwise_dispersion_populus_interact <- TukeyHSD(phen.disper.populus.interact)

head(pairwise_dispersion_populus_interact)
```



## POPULUS Beta Diversity PERMANOVA:############################################

Question: Do growing degree days significantly influence the community composition (beta diversity) within Populus?

```{r}
# Filter data for Populus_tremuloides
populus_data <- asv_scaled_noPlants_Phen_filt_LMM[asv_scaled_noPlants_Phen_filt_LMM$Species == "Populus_tremuloides", ]

# Perform PERMANOVA for Populus_tremuloides
permanova_populus_beta <- adonis2(dist.mat_populus ~ GDD_5C * Plant_ID, data = populus_data, permutations = 999)

# Print PERMANOVA results for Populus_tremuloides
print(permanova_populus_beta)
```


################################################################################
## RELATIVE ABUNDANCE (INTRA)
################################################################################

## Betula populifolia

```{r}
# Run the LMM
lmm_rel_abund_betula1 <- lmer(RelativeAbundance ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Betula_populifolia")
lmm_rel_abund_betula2 <- lmer(sqrt(RelativeAbundance) ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Betula_populifolia")
lmm_rel_abund_betula3 <- lmer(I(RelativeAbundance^2) ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Betula_populifolia")

summary(lmm_rel_abund_betula1)
summary(lmm_rel_abund_betula2)
summary(lmm_rel_abund_betula3)

anova(lmm_rel_abund_betula1, lmm_rel_abund_betula2, lmm_rel_abund_betula3)
```


```{r}
# Run the LMM
lmm_rel_abund_populus1 <- lmer(RelativeAbundance ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Populus_tremuloides")
lmm_rel_abund_populus2 <- lmer(sqrt(RelativeAbundance) ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Populus_tremuloides")
lmm_rel_abund_populus3 <- lmer(I(RelativeAbundance^2) ~ Plant_ID + GDD_5C + Plant_ID:GDD_5C + (1 | sample_id), data = combined_df, subset = Species == "Populus_tremuloides")

summary(lmm_rel_abund_populus1)
summary(lmm_rel_abund_populus2)
summary(lmm_rel_abund_populus3)

anova(lmm_rel_abund_populus1, lmm_rel_abund_populus2, lmm_rel_abund_populus3)
```


################################################################################
## FUNCTIONAL TRAIT ASSESSMENT
################################################################################

```{r}
# Join trait data
asv_scaled_noPlants_Phen_filt_LMM<-plyr::join(asv_scaled_noPlants_Phen_filt_LMM, refl_trait_data, by="sample_id", type="left")

# Impute NAs with median for numeric columns
asv_scaled_noPlants_Phen_filt_LMM[, sapply(asv_scaled_noPlants_Phen_filt_LMM, is.numeric)] <-
  lapply(asv_scaled_noPlants_Phen_filt_LMM[, sapply(asv_scaled_noPlants_Phen_filt_LMM, is.numeric)], 
         function(x) ifelse(is.na(x), median(x, na.rm = TRUE), x))
```


################################################################################
##        INTERSPECIFIC VARIATION (FUNCTIONAL TRAITS) - **MASS BASED**
################################################################################
################################################################################
# ASV RICHNESS & FUNCTIONAL TRAITS
################################################################################

```{r}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#ASV Richness
model_null_richness <- lm(log(specnumber) ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_richness <- stepAIC(
  model_null_richness,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + Al_mass + B208.9_mass + B249.8_mass + Ca_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass 
# +
# Narea  + Carea + solubles_area + hemicellulose_area + cellulose_area + lignin_area + chlA_area + chlB_area + car_area + Al_area + Ca_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area
, direction = "forward"
)

step_f_richness$anova
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_richness <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  log(specnumber) ~ Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + B208.9_mass + B249.8_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_richness)

permanova_traits_richness
```


################################################################################
# SHANNON DIVERSITY & FUNCTIONAL TRAITS
################################################################################

```{r}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#Shannon Index
model_null_shannon <- lm(sqrt(alphaDiv) ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_shannon <- stepAIC(
  model_null_shannon,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + Al_mass + B208.9_mass + B249.8_mass + Ca_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass, direction = "forward"
)

step_f_shannon$anova
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_shannon <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  sqrt(alphaDiv) ~ Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + B208.9_mass + B249.8_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_shannon)

permanova_traits_shannon
```


################################################################################
# BETA DIVERSITY & FUNCTIONAL TRAITS
################################################################################

```{r, eval = FALSE}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#Beta Diversity
model_null_beta <- lm(dist.mat ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_beta <- stepAIC(
  model_null_beta,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + Al_mass + B208.9_mass + B249.8_mass + Ca_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass, direction = "forward"
)

step_f_beta$anova
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_beta <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  dist.mat ~ Species + GDD_5C + LMA + LDMC + EWT + Cmass + Nmass + solubles_mass + hemicellulose_mass + cellulose_mass +
  lignin_mass + chlA_mass + chlB_mass + car_mass + B208.9_mass + B249.8_mass + Cu_mass + Fe_mass + K_mass + Mg_mass + Mn_mass + Na_mass + P_mass + Zn_mass,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_beta)

permanova_traits_beta
```


################################################################################
## RDA
################################################################################

```{r}
#install.packages(
#  "microViz",
#  repos = c(davidbarnett = "https://david-barnett.r-universe.dev", getOption("repos"))
#)
#install.packages("ggtext") # for rotated labels on ord_plot() 
#install.packages("ggraph") # for taxatree_plots()
#install.packages("DT") # for tax_fix_interactive()

library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_phyla <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
#  ps_mutate(
#    LMA = as.numeric(LMA == "LMA"),
#    LDMC = as.numeric(LDMC == "LDMC"),
#    Nmass = as.numeric(Nmass == "Nmass"),
#    solubles_mass = as.numeric(solubles_mass == "solubles_mass"),
#    hemicellulose_mass = as.numeric(hemicellulose_mass == "hemicellulose_mass"),
#    cellulose_mass = as.numeric(cellulose_mass == "cellulose_mass"),
#    lignin_mass = as.numeric(lignin_mass == "lignin_mass"),
#    chlB_mass = as.numeric(chlB_mass == "chlB_mass"),
#    B208.9_mass = as.numeric(B208.9_mass == "B208.9_mass"),
#    Cu_mass = as.numeric(Cu_mass == "Cu_mass"),
#    K_mass = as.numeric(K_mass == "K_mass"),
#    Mg_mass = as.numeric(Mg_mass == "Mg_mass"),
#    Narea = as.numeric(Narea == "Narea"),
#    solubles_area = as.numeric(solubles_area == "solubles_area"),
#    hemicellulose_area = as.numeric(hemicellulose_area == "hemicellulose_area"),
#    lignin_area = as.numeric(lignin_area == "lignin_area"),
#    Al_area = as.numeric(Al_area == "Al_area"),
#    Ca_area = as.numeric(Ca_area == "Ca_area"),
#    Cu_area = as.numeric(Cu_area == "Cu_area"),
#    K_area = as.numeric(K_area == "K_area"),
#    Mn_area = as.numeric(Mn_area == "Mn_area")
#  ) %>%
  tax_transform("clr", rank = "Phylum") %>%
  ord_calc(
    constraints = c("LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_phyla
```

```{r}
# calculate distances
aitchison_dists <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Phylum") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm <- aitchison_dists %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass")
  )
#> 2023-09-02 10:25:27.865162 - Starting PERMANOVA with 99 perms with 1 processes
#> 2023-09-02 10:25:27.944922 - Finished PERMANOVA

# view the permanova results
perm_get(aitchison_perm) %>% as.data.frame()
```

```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_phyla <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_transform("clr", rank = "Phylum") %>%
  ord_calc(
    constraints = c("LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:10,
    tax_vec_length = 4.6, # this value is a scalar multiplier for the biplot score vectors
    tax_lab_length = 5, # this multiplier moves the labels, independently of the arrowheads
    tax_lab_style = tax_lab_style(size = 3, alpha = 0.5), # create a list of options to tweak the taxa labels' default style
    constraint_vec_length = 7, # this adjusts the length of the constraint arrows, and the labels track these lengths by default
    constraint_vec_style = vec_constraint(1, alpha = 0.5), # this styles the constraint arrows
    constraint_lab_style = constraint_lab_style(size = 3, alpha = 0.5) # this styles the constraint labels
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_phyla
```

```{r}
# calculate distances
aitchison_dists_phyla <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Phylum") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm_phyla <- aitchison_dists_phyla %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass")
  )

# view the permanova results
perm_get(aitchison_perm_phyla) %>% as.data.frame()
```


```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_genus <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
#  ps_mutate(
#    LMA = as.numeric(LMA == "LMA"),
#    LDMC = as.numeric(LDMC == "LDMC"),
#    Nmass = as.numeric(Nmass == "Nmass"),
#    solubles_mass = as.numeric(solubles_mass == "solubles_mass"),
#    hemicellulose_mass = as.numeric(hemicellulose_mass == "hemicellulose_mass"),
#    cellulose_mass = as.numeric(cellulose_mass == "cellulose_mass"),
#    lignin_mass = as.numeric(lignin_mass == "lignin_mass"),
#    chlB_mass = as.numeric(chlB_mass == "chlB_mass"),
#    B208.9_mass = as.numeric(B208.9_mass == "B208.9_mass"),
#    Cu_mass = as.numeric(Cu_mass == "Cu_mass"),
#    K_mass = as.numeric(K_mass == "K_mass"),
#    Mg_mass = as.numeric(Mg_mass == "Mg_mass"),
#    Narea = as.numeric(Narea == "Narea"),
#    solubles_area = as.numeric(solubles_area == "solubles_area"),
#    hemicellulose_area = as.numeric(hemicellulose_area == "hemicellulose_area"),
#    lignin_area = as.numeric(lignin_area == "lignin_area"),
#    Al_area = as.numeric(Al_area == "Al_area"),
#    Ca_area = as.numeric(Ca_area == "Ca_area"),
#    Cu_area = as.numeric(Cu_area == "Cu_area"),
#    K_area = as.numeric(K_area == "K_area"),
#    Mn_area = as.numeric(Mn_area == "Mn_area")
#  ) %>%
  tax_transform("clr", rank = "Genus") %>%
  ord_calc(
    constraints = c("LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = FALSE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", auto_caption = NA, size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_genus
```


```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_genus <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_transform("clr", rank = "Genus") %>%
  ord_calc(
    constraints = c("LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20,
    tax_vec_length = 6.6, # this value is a scalar multiplier for the biplot score vectors
    tax_lab_length = 7, # this multiplier moves the labels, independently of the arrowheads
    tax_lab_style = tax_lab_style(size = 2.5, alpha = 0.5), # create a list of options to tweak the taxa labels' default style
    constraint_vec_length = 10, # this adjusts the length of the constraint arrows, and the labels track these lengths by default
    constraint_vec_style = vec_constraint(1, alpha = 0.5), # this styles the constraint arrows
    constraint_lab_style = constraint_lab_style(size = 2.5, alpha = 0.5) # this styles the constraint labels
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_genus
```

```{r}
# calculate distances
aitchison_dists_genus <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Genus") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm_genus <- aitchison_dists_genus %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass")
  )

# view the permanova results
perm_get(aitchison_perm_genus) %>% as.data.frame()
```



```{r}
## SIGNIFICANCE TESTS

ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 5 / 100, tax_level = "Genus") %>%
  tax_agg("Genus") %>%
  dist_calc("aitchison") %>%
  dist_permanova(
    variables = c("Species", "GDD_5C", "LMA", "LDMC", "solubles_mass", "hemicellulose_mass", "lignin_mass", "Nmass", "B208.9_mass", "Ca_mass", "K_mass", "Al_mass", "Cu_mass", "Mg_mass", "Zn_mass"),
    n_perms = 999, # this is a low number of permutations for speed, you should set more e.g. 9999
    seed = 12345, complete_cases = TRUE, verbose = "max"
  )
```

*Here are some potential interpretations:*

1. Functional Traits and Diversity:

The significant results in the PERMANOVA analysis on microbial diversity metrics indicate that the set of functional traits collectively has an impact on the overall microbial community structure. This suggests that the traits influence the diversity metrics (ASV richness and Shannon diversity).

2. RDA Results and Taxa-Specific Effects:

The non-significant results in the RDA analysis may suggest that the specific functional traits you included do not directly explain the variation in the abundance or composition of individual microbial taxa. In other words, while the functional traits collectively influence overall diversity, they may not be strong predictors of the abundance or presence of particular microbial taxa.

3. Consideration of Other Factors:

It's also possible that other unmeasured factors or additional functional traits not included in your analysis might be influencing the composition of specific microbial taxa. Microbial communities are complex, and their structure can be influenced by a variety of biotic and abiotic factors.

4. Biological Relevance:

Evaluate the biological relevance of the results. Even if the functional traits are not significant in the RDA, it doesn't necessarily mean they have no biological importance. The lack of significance could be due to the complexity of microbial interactions and the limitations of the variables considered in the analysis.

5. Consideration of Different Scales:

Microbial diversity metrics might capture community-level changes, while taxa-specific analyses may focus on finer-scale interactions. Consider the scale at which your functional traits and diversity metrics operate and how this might impact their associations with specific taxa.

6. Exploratory Nature of RDA:

RDA is an exploratory technique, and the significance of individual variables may vary depending on the context and the specific ecological dynamics of your system. Visual exploration of the RDA plot, even in the absence of statistical significance, can provide insights into potential associations.

In summary, the discrepancy suggests that while the functional traits collectively influence overall microbial diversity, they may not be directly linked to the abundance or composition of specific microbial taxa. The interpretation should be made in the context of the scale of analysis, the complexity of microbial communities, and the limitations of the variables considered. Consider further exploration, potentially incorporating additional variables or conducting targeted analyses on specific taxa of interest to gain a more comprehensive understanding of the relationships in your metagenomics project.

**ADDRESSING DISCREPANCIES:**

1. For Beta Diversity (PERMANOVA):

"The results of the beta diversity analysis, as assessed through PERMANOVA, indicate that 'Species' and 'GDD_5C' are highly significant factors influencing the overall compositional changes in the microbial community. This suggests that there are significant differences in community composition when considering the broader taxonomic landscape."

2. For RDA (Functional Traits):

"In contrast, the Redundancy Analysis (RDA) results, which explore the relationship between specific functional traits and individual microbial taxa, reveal that while 'Species' and 'GDD_5C' remain influential, their individual predictive power for explaining the variation in abundance of specific taxa is less pronounced. This could be due to the complexity of interactions within the microbial community, the presence of unmeasured variables, or potential non-linear relationships."

3. Integration of Findings:

"Taken together, these results suggest that 'Species' and 'GDD_5C' have a significant impact on the overall structure of the microbial community, as evidenced by their influence on beta diversity. However, when examining the associations at the taxonomic level through RDA, the explanatory power of these factors becomes more nuanced, highlighting the importance of considering additional variables and potential interactions in explaining specific taxonomic variations."

4. Consideration of Biological Context:

"It is important to interpret these findings in the context of the ecological dynamics of the microbial community, recognizing that factors influencing overall community composition may differ from those influencing individual taxa. The observed differences emphasize the need for a comprehensive understanding of the microbial community, encompassing both broad-scale patterns and finer-scale taxonomic dynamics."

By framing your interpretation in this way, you acknowledge the complexity of microbial community dynamics and provide a more comprehensive understanding of how environmental factors (like 'Species' and 'GDD_5C') influence the community at different scales. This approach allows for a nuanced and accurate representation of your findings in your written work.


```{r, eval = FALSE}
# install.packages("remotes")
#remotes::install_github("statdivlab/corncob")
library(corncob)

tt_models <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0 / 100, tax_level = "Genus") %>%
  taxatree_models(
    ranks = c("Phylum", "Family"),
    variables = c("LMA", "cellulose_mass", "B208.9_mass", "Cu_mass", "Narea", "hemicellulose_area"),
    type = "bbdml", verbose = "max"
  )
tt_stats <- taxatree_models2stats(tt_models, param = "mu")
```


```{r, eval = FALSE}
install.packages("microeco")

t1 <- trans_diff$new(dataset = ps_phen_asv_transposed_LMM, method = "lefse", group = "Species", alpha = 0.01, lefse_subgroup = "GDD_5C")
# see t1$res_diff for the result
# From v0.8.0, threshold is used for the LDA score selection.
t1$plot_diff_bar(threshold = 4)
# we show 20 taxa with the highest LDA (log10)
t1$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c("Betula_populifolia", "Populus_tremuloide"))
```


################################################################################
##        INTERSPECIFIC VARIATION (FUNCTIONAL TRAITS) - **AREA BASED**
################################################################################
################################################################################
# ASV RICHNESS & FUNCTIONAL TRAITS
################################################################################

```{r}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#ASV Richness
model_null_richness <- lm(log(specnumber) ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_richness_area <- stepAIC(
  model_null_richness,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Al_area + Ca_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area, direction = "forward")

step_f_richness_area$anova

#Final Model: log(specnumber) ~ Al_area + solubles_area + K_area + Ca_area
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_richness_area <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  log(specnumber) ~ Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_richness_area)

permanova_traits_richness_area

#Signif. Traits: LMA, solubles_area, cellulose_area, lignin_area, chlB_area, Cu_area
```


################################################################################
# SHANNON DIVERSITY & FUNCTIONAL TRAITS
################################################################################

```{r}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#Shannon Index
model_null_shannon <- lm(sqrt(alphaDiv) ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_shannon_area <- stepAIC(
  model_null_shannon,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Al_area + Ca_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area, direction = "forward"
)

step_f_shannon_area$anova

#Final Model: sqrt(alphaDiv) ~ Species + hemicellulose_area + K_area + Narea + Na_area + cellulose_area
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_shannon_area <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  sqrt(alphaDiv) ~ Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_shannon_area)

permanova_traits_shannon_area

#Signif. Traits: LMA, Narea (p=0.1, not signif, but close), hemicellulose_area, K_area (p=0.079), Na_area
```


################################################################################
# BETA DIVERSITY & FUNCTIONAL TRAITS
################################################################################

```{r, eval = FALSE}
#-------------------------------------------------------------------------
# Forward selection approach
#-------------------------------------------------------------------------

#Beta Diversity
model_null_beta <- lm(dist.mat ~ 1, data = asv_scaled_noPlants_Phen_filt_LMM)

step_f_beta_area <- stepAIC(
  model_null_beta,
  scope = ~ . + Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Al_area + Ca_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area, direction = "forward"
)

step_f_beta_area$anova
```

```{r}
# Perform PERMANOVA
library(vegan)

# Now, perform the PERMANOVA analysis with the updated formula
permanova_traits_beta_area <- with(asv_scaled_noPlants_Phen_filt_LMM, adonis2(
  dist.mat ~ Species + GDD_5C + LMA + LDMC + EWT + Carea + Narea + solubles_area + hemicellulose_area + cellulose_area +
  lignin_area + chlA_area + chlB_area + car_area + Cu_area + Fe_area + K_area + Mg_area + Mn_area + Na_area + P_area + Zn_area,
  na.action = na.exclude, permutations = 999
))

# Summarize the PERMANOVA results
summary(permanova_traits_beta_area)

permanova_traits_beta_area

#Signif. Traits: LMA, LDMC (p=0.094), lignin_mass (0.098), Mg_mass (p=0.095), Zn_mass (p=0.064)
```


################################################################################
## RDA
################################################################################

```{r}
#install.packages(
#  "microViz",
#  repos = c(davidbarnett = "https://david-barnett.r-universe.dev", getOption("repos"))
#)
#install.packages("ggtext") # for rotated labels on ord_plot() 
#install.packages("ggraph") # for taxatree_plots()
#install.packages("DT") # for tax_fix_interactive()

library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_phyla_area <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
#  ps_mutate(
#    LMA = as.numeric(LMA == "LMA"),
#    LDMC = as.numeric(LDMC == "LDMC"),
#    Nmass = as.numeric(Nmass == "Nmass"),
#    solubles_mass = as.numeric(solubles_mass == "solubles_mass"),
#    hemicellulose_mass = as.numeric(hemicellulose_mass == "hemicellulose_mass"),
#    cellulose_mass = as.numeric(cellulose_mass == "cellulose_mass"),
#    lignin_mass = as.numeric(lignin_mass == "lignin_mass"),
#    chlB_mass = as.numeric(chlB_mass == "chlB_mass"),
#    B208.9_mass = as.numeric(B208.9_mass == "B208.9_mass"),
#    Cu_mass = as.numeric(Cu_mass == "Cu_mass"),
#    K_mass = as.numeric(K_mass == "K_mass"),
#    Mg_mass = as.numeric(Mg_mass == "Mg_mass"),
#    Narea = as.numeric(Narea == "Narea"),
#    solubles_area = as.numeric(solubles_area == "solubles_area"),
#    hemicellulose_area = as.numeric(hemicellulose_area == "hemicellulose_area"),
#    lignin_area = as.numeric(lignin_area == "lignin_area"),
#    Al_area = as.numeric(Al_area == "Al_area"),
#    Ca_area = as.numeric(Ca_area == "Ca_area"),
#    Cu_area = as.numeric(Cu_area == "Cu_area"),
#    K_area = as.numeric(K_area == "K_area"),
#    Mn_area = as.numeric(Mn_area == "Mn_area")
#  ) %>%
  tax_transform("clr", rank = "Phylum") %>%
  ord_calc(
    constraints = c("LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_phyla_area
```

```{r}
# calculate distances
aitchison_dists_area <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Phylum") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm_area <- aitchison_dists_area %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area")
  )
#> 2023-09-02 10:25:27.865162 - Starting PERMANOVA with 99 perms with 1 processes
#> 2023-09-02 10:25:27.944922 - Finished PERMANOVA

# view the permanova results
perm_get(aitchison_perm_area) %>% as.data.frame()
```

```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_phyla_area <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_transform("clr", rank = "Phylum") %>%
  ord_calc(
    constraints = c("LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:10,
    tax_vec_length = 4.6, # this value is a scalar multiplier for the biplot score vectors
    tax_lab_length = 5, # this multiplier moves the labels, independently of the arrowheads
    tax_lab_style = tax_lab_style(size = 3, alpha = 0.5), # create a list of options to tweak the taxa labels' default style
    constraint_vec_length = 7, # this adjusts the length of the constraint arrows, and the labels track these lengths by default
    constraint_vec_style = vec_constraint(1, alpha = 0.5), # this styles the constraint arrows
    constraint_lab_style = constraint_lab_style(size = 3, alpha = 0.5) # this styles the constraint labels
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_phyla_area
```

```{r}
# calculate distances
aitchison_dists_phyla_area <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Phylum") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm_phyla_area <- aitchison_dists_phyla_area %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area")
  )

# view the permanova results
perm_get(aitchison_perm_phyla_area) %>% as.data.frame()
```


```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_genus_area <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
#  ps_mutate(
#    LMA = as.numeric(LMA == "LMA"),
#    LDMC = as.numeric(LDMC == "LDMC"),
#    Nmass = as.numeric(Nmass == "Nmass"),
#    solubles_mass = as.numeric(solubles_mass == "solubles_mass"),
#    hemicellulose_mass = as.numeric(hemicellulose_mass == "hemicellulose_mass"),
#    cellulose_mass = as.numeric(cellulose_mass == "cellulose_mass"),
#    lignin_mass = as.numeric(lignin_mass == "lignin_mass"),
#    chlB_mass = as.numeric(chlB_mass == "chlB_mass"),
#    B208.9_mass = as.numeric(B208.9_mass == "B208.9_mass"),
#    Cu_mass = as.numeric(Cu_mass == "Cu_mass"),
#    K_mass = as.numeric(K_mass == "K_mass"),
#    Mg_mass = as.numeric(Mg_mass == "Mg_mass"),
#    Narea = as.numeric(Narea == "Narea"),
#    solubles_area = as.numeric(solubles_area == "solubles_area"),
#    hemicellulose_area = as.numeric(hemicellulose_area == "hemicellulose_area"),
#    lignin_area = as.numeric(lignin_area == "lignin_area"),
#    Al_area = as.numeric(Al_area == "Al_area"),
#    Ca_area = as.numeric(Ca_area == "Ca_area"),
#    Cu_area = as.numeric(Cu_area == "Cu_area"),
#    K_area = as.numeric(K_area == "K_area"),
#    Mn_area = as.numeric(Mn_area == "Mn_area")
#  ) %>%
  tax_transform("clr", rank = "Genus") %>%
  ord_calc(
    constraints = c("LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = FALSE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", auto_caption = NA, size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_genus_area
```


```{r}
library(microViz)
library(ggtext)
library(ggraph)
library(DT)

#ps_phen_asv_LMM %>% tax_fix()
#tax_fix_interactive(ps_phen_asv_LMM)

tax_table(ps_phen_asv_LMM)["ASV1783", ] <- c("Bacteria", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium", "uncultured_bacterium")

rda_plot_genus_area <- ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_transform("clr", rank = "Genus") %>%
  ord_calc(
    constraints = c("LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area"),
    method = "RDA", # Note: you can specify RDA explicitly, and it is good practice to do so, but microViz can guess automatically that you want an RDA here (helpful if you don't remember the name?)
    scale_cc = TRUE # doesn't make a difference
  ) %>%
  ord_plot(
    colour = "Species", size = 2, alpha = 0.5, shape = "GDD_5C",
    plot_taxa = 1:20,
    tax_vec_length = 6.6, # this value is a scalar multiplier for the biplot score vectors
    tax_lab_length = 7, # this multiplier moves the labels, independently of the arrowheads
    tax_lab_style = tax_lab_style(size = 2.5, alpha = 0.5), # create a list of options to tweak the taxa labels' default style
    constraint_vec_length = 10, # this adjusts the length of the constraint arrows, and the labels track these lengths by default
    constraint_vec_style = vec_constraint(1, alpha = 0.5), # this styles the constraint arrows
    constraint_lab_style = constraint_lab_style(size = 2.5, alpha = 0.5) # this styles the constraint labels
  ) +
    scale_shape_manual(values = c(16, 18, 17, 15, 3, 7, 8
  ))

rda_plot_genus_area
```

```{r}
# calculate distances
aitchison_dists_genus_area <- ps_phen_asv_LMM %>%
    tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 0.1) %>%
  tax_transform("identity", rank = "Genus") %>%
  dist_calc("aitchison")
#> Proportional min_prevalence given: 0.1 --> min 23/222 samples.

# the more permutations you request, the longer it takes
# but also the more stable and precise your p-values become
aitchison_perm_genus_area <- aitchison_dists_genus_area %>%
  dist_permanova(
    seed = 1234, # for set.seed to ensure reproducibility of random process
    n_processes = 1, n_perms = 999, # you should use at least 999!
    variables = c("Species", "GDD_5C", "LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area")
  )

# view the permanova results
perm_get(aitchison_perm_genus_area) %>% as.data.frame()
```



```{r}
## SIGNIFICANCE TESTS

ps_phen_asv_LMM %>%
  tax_fix(
  min_length = 0,
  unknowns = c("Unknown Family", "NA"),
  sep = " ", anon_unique = TRUE,
  suffix_rank = "current"
 ) %>%
  tax_filter(min_prevalence = 5 / 100, tax_level = "Genus") %>%
  tax_agg("Genus") %>%
  dist_calc("aitchison") %>%
  dist_permanova(
    variables = c("Species", "GDD_5C", "LMA", "solubles_area", "cellulose_area", "hemicellulose_area", "lignin_mass", "Narea", "Na_area", "K_area", "Ca_area", "Cu_area", "chlA_area", "chlB_area", "Al_area", "Mn_area", "Mg_area"),
    n_perms = 999, # this is a low number of permutations for speed, you should set more e.g. 9999
    seed = 12345, complete_cases = TRUE, verbose = "max"
  )
```

################################################################################
## FUNCTIONAL TRAIT-ASV CORRELATION COEFFICIENTS???
################################################################################

```{r}
#E.g.:
cor(asv_scaled_noPlants_Phen_filt_LMM$ASV10, asv_scaled_noPlants_Phen_filt_LMM$Mg_mass)
```

